<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Kotlin Beginners Notes</title>
        <style>
/* From extension zhuangtongfa.material-theme */
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body {
  box-sizing: border-box;
  min-width: 200px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body blockquote {
  background-color: initial;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre {
  color: initial;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body code {
  color: inherit;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre code {
  color: initial;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body code > div {
  background: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table th, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table td {
  border: 1px solid rgba(171, 178, 191, 0.5) !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body.showEditorSelection .code-active-line:before {
  border-left: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body.showEditorSelection .code-line:hover:before {
  border-left: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body.showEditorSelection .code-line .code-line:hover:before {
  border-left: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body p, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body blockquote, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ul, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ol, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body dl, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre {
  margin-top: 16px;
  margin-bottom: 16px;
}

/* Generated from 'node_modules/github-markdown-css/github-markdown.css' */
@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format("woff");
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  line-height: 1.5;
  color: #abb2bf;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
  background: #282c34;
  padding-top: 20px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-c {
  color: #6a737d;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-c1, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-s .pl-v {
  color: #005cc5;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-e, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-en {
  color: #6f42c1;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-smi, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-s .pl-s1 {
  color: #24292e;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-ent {
  color: #22863a;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-k {
  color: #d73a49;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-s, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-pds, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-s .pl-pse .pl-s1, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-sr, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-sr .pl-cce, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-sr .pl-sre, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-sr .pl-sra {
  color: #032f62;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-v, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-smw {
  color: #e36209;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-bu {
  color: #b31d28;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-ii {
  color: #fafbfc;
  background-color: #b31d28;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-c2 {
  color: #fafbfc;
  background-color: #d73a49;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-c2::before {
  content: "^M";
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-sr .pl-cce {
  font-weight: bold;
  color: #22863a;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-ml {
  color: #735c0f;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-mh, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-mh .pl-en, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-ms {
  font-weight: bold;
  color: #005cc5;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-mi {
  font-style: italic;
  color: #24292e;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-mb {
  font-weight: bold;
  color: #24292e;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-md {
  color: #b31d28;
  background-color: #ffeef0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-mi1 {
  color: #22863a;
  background-color: #f0fff4;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-mc {
  color: #e36209;
  background-color: #ffebda;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-mi2 {
  color: #f6f8fa;
  background-color: #005cc5;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-mdr {
  font-weight: bold;
  color: #6f42c1;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-ba {
  color: #586069;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-sg {
  color: #959da5;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-corl {
  text-decoration: underline;
  color: #032f62;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .octicon {
  display: inline-block;
  vertical-align: text-top;
  fill: currentColor;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body a {
  background-color: transparent;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body a:active, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body a:hover {
  outline-width: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body strong {
  font-weight: inherit;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body strong {
  font-weight: bolder;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body img {
  border-style: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body code, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body kbd, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body input {
  font: inherit;
  margin: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body input {
  overflow: visible;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body * {
  box-sizing: border-box;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body a {
  color: #528bff;
  text-decoration: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body a:hover {
  text-decoration: underline;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body strong {
  font-weight: 600;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body hr::before {
  display: table;
  content: "";
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body hr::after {
  display: table;
  clear: both;
  content: "";
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table {
  border-spacing: 0;
  border-collapse: collapse;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body td, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body th {
  padding: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h1, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h2, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h3, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h4, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h5, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h6 {
  margin-top: 0;
  margin-bottom: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h1 {
  font-size: 32px;
  font-weight: 600;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h2 {
  font-size: 24px;
  font-weight: 600;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h3 {
  font-size: 20px;
  font-weight: 600;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h4 {
  font-size: 16px;
  font-weight: 600;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h5 {
  font-size: 14px;
  font-weight: 600;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h6 {
  font-size: 12px;
  font-weight: 600;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body p {
  margin-top: 0;
  margin-bottom: 10px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body blockquote {
  margin: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ul, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ol {
  padding-left: 0;
  margin-top: 0;
  margin-bottom: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ol ol, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ul ol {
  list-style-type: lower-roman;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ul ul ol, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ul ol ol, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ol ul ol, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ol ol ol {
  list-style-type: lower-alpha;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body dd {
  margin-left: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body code {
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .octicon {
  vertical-align: text-bottom;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-0 {
  padding-left: 0 !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-1 {
  padding-left: 4px !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-2 {
  padding-left: 8px !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-3 {
  padding-left: 16px !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-4 {
  padding-left: 24px !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-5 {
  padding-left: 32px !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .pl-6 {
  padding-left: 40px !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body::before {
  display: table;
  content: "";
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body::after {
  display: table;
  clear: both;
  content: "";
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body > *:first-child {
  margin-top: 0 !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body > *:last-child {
  margin-bottom: 0 !important;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .anchor:focus {
  outline: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body p, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body blockquote, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ul, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ol, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body dl, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body hr {
  height: 0.25em;
  padding: 0;
  margin: 24px 0;
  background-color: #e1e4e8;
  border: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body blockquote {
  /* padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5; */
  padding: 8.5px 17px;
  margin: 1.5em 0;
  font-size: inherit;
  color: #7c879c;
  border-color: #4b5362;
  border-width: 4px;
  border-left: 5px solid #4b5362;
  background: transparent;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body blockquote > :first-child {
  margin-top: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body blockquote > :last-child {
  margin-bottom: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: solid 1px #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h1, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h2, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h3, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h4, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h5, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
  color: #f0f0f0;
  border-bottom: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h1 .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h2 .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h3 .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h4 .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h5 .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h1:hover .anchor, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h2:hover .anchor, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h3:hover .anchor, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h4:hover .anchor, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h5:hover .anchor, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h6:hover .anchor {
  text-decoration: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h1:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h2:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h3:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h4:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h5:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h6:hover .anchor .octicon-link {
  visibility: visible;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h1 {
  padding-bottom: 0.3em;
  font-size: 2em;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.5em;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h3 {
  font-size: 1.25em;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h4 {
  font-size: 1em;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h5 {
  font-size: 0.875em;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body h6 {
  font-size: 0.85em;
  color: #6a737d;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ul, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ol {
  padding-left: 2em;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ul ul, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ul ol, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ol ol, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body li {
  word-wrap: break-all;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body li > p {
  margin-top: 16px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body li + li {
  margin-top: 0.25em;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body dl {
  padding: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table {
  display: block;
  width: 100%;
  overflow: auto;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table th {
  font-weight: 700;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table th, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table td {
  padding: 6px 13px;
  /* border: 1px solid #dfe2e5; */
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table tr {
  /* background-color: #fff; */
  /* border-top: 1px solid #c6cbd1; */
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body table tr:nth-child(2n) {
  /* background-color: #f6f8fa; */
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body img {
  max-width: 100%;
  box-sizing: content-box;
  display: inline-block;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body img[align=right] {
  padding-left: 20px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body img[align=left] {
  padding-right: 20px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: #3a3f4b;
  border-radius: 3px;
  color: white;
  margin: 0 1px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre {
  word-wrap: normal;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre > code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .highlight {
  margin-bottom: 16px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .highlight pre, .vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  /* background-color: #f6f8fa; */
  border-radius: 3px;
  background-color: #31363f;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body pre code {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
  color: #abb2bf;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .full-commit .btn-outline:not(:disabled):hover {
  color: #005cc5;
  border-color: #005cc5;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: solid 1px #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body :checked + .radio-label {
  position: relative;
  z-index: 1;
  border-color: #0366d6;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .task-list-item {
  list-style-type: none;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .task-list-item + .task-list-item {
  margin-top: 3px;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body .task-list-item input {
  margin: 0 0.2em 0.25em -1.6em;
  vertical-align: middle;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"].vscode-body hr {
  border-bottom-color: #eee;
}

/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-comment,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-quote {
  color: #5c6370;
  font-style: italic;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-doctag,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-keyword,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-formula {
  color: #c678dd;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-section,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-name,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-selector-tag,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-deletion,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-subst {
  color: #e06c75;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-literal {
  color: #56b6c2;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-string,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-regexp,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-addition,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-attribute,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-meta-string {
  color: #98c379;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-built_in,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-class .hljs-title {
  color: #e6c07b;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-attr,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-variable,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-template-variable,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-type,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-selector-class,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-selector-attr,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-selector-pseudo,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-number {
  color: #d19a66;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-symbol,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-bullet,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-link,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-meta,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-selector-id,
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-title {
  color: #61aeee;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-emphasis {
  font-style: italic;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-strong {
  font-weight: bold;
}
.vscode-dark[data-vscode-theme-name="One Dark Pro"] .hljs-link {
  text-decoration: underline;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="kotlin-beginners-notes">Kotlin Beginners Notes</h1>
<p>These are all personal notes taken from the Udacity Course (ud9011) of Kotlin Bootcamp for Programmers by Google as well as other resources. You can use it to learn Kotlin if you are a <strong>beginner</strong>, I have taken most of the things mentioned in the all sections/videos of this course including some brief pieces from official documentation and official video of JetBrains as well. I also cared about the order of the topics, so it starts from the basics from top to bottom goes to the more advanced ones. This is not an official documentation. You will be probably finding more personal notes and human mistakes :)</p>
<p><img src="https://user-images.githubusercontent.com/36234545/127040534-c2448cfd-a4c4-43cd-9bb3-c03787b37e51.png" alt="2021-07-26 21_33_44-Editing Kotlin-Notes_README md at main · shtanriverdi_Kotlin-Notes — Mozilla Fir"></p>
<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#l1">Lesson 1 &amp; 2 Introduction | Kotlin Basics</a></li>
<li><a href="#l3">Lesson 3 | Functions</a></li>
<li><a href="#l4">Lesson 4 | Classes</a></li>
<li><a href="#l5">Lesson 5 | Kotlin Essentials: Beyond The Basics</a></li>
</ul>
<h2 id="l1">Lesson 1 & 2 Introduction | Kotlin Basics</h2>
<h3 id="package-definition-and-imports">Package Definition and Imports</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Package specification should be at the top of the source file.</span>
<span class="hljs-keyword">package</span> my.demo

<span class="hljs-keyword">import</span> kotlin.text.*

<span class="hljs-comment">// Main function</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    printHello ()
}

<span class="hljs-comment">// Alternative main, no need to write parameters!</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    printHello ()
}

<span class="hljs-comment">// Prints &quot;Hello Kotlin&quot;, println() puts newline, print()</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printHello</span> <span class="hljs-params">()</span></span> {
    println(<span class="hljs-string">&quot;Hello Kotlin!&quot;</span>)
}

<span class="hljs-comment">// A function that returns &quot;OK&quot; string</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>: String = <span class="hljs-string">&quot;OK&quot;</span>

<span class="hljs-comment">// Function returns &quot;Genesis&quot;, no need to write &quot;return&quot;</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returnString</span> <span class="hljs-params">()</span></span> : String = <span class="hljs-string">&quot;Genesis&quot;</span>

<span class="hljs-comment">// Function returns &quot;Genesis2&quot; Alternative Way</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returnString2</span> <span class="hljs-params">()</span></span> : String {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Genesis2&quot;</span>
}
</div></code></pre>
<h3 id="operators-----">Operators, -, +, /, *</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Returns integer</span>
println(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>) <span class="hljs-comment">// Prints: 2</span>
println(<span class="hljs-number">53</span> - <span class="hljs-number">3</span>) <span class="hljs-comment">// Prints: 50</span>
println(<span class="hljs-number">50</span> / <span class="hljs-number">10</span>) <span class="hljs-comment">// Prints: 5</span>
println(<span class="hljs-number">1</span> / <span class="hljs-number">2</span>) <span class="hljs-comment">// Prints: 0</span>
println(<span class="hljs-number">6</span> * <span class="hljs-number">50</span>) <span class="hljs-comment">// Prints: 300</span>

<span class="hljs-comment">// Returns double</span>
println(<span class="hljs-number">1.0</span> / <span class="hljs-number">2.0</span>) <span class="hljs-comment">// Prints: 0.5</span>
println(<span class="hljs-number">1.0</span> / <span class="hljs-number">2</span>) <span class="hljs-comment">// Prints: 0.5</span>
println(<span class="hljs-number">2</span> / <span class="hljs-number">2.0</span>) <span class="hljs-comment">// Prints: 1.0</span>

<span class="hljs-comment">// Kotlin let&#x27;s you overwrite the basic operators</span>
<span class="hljs-comment">// You can call methods on variables</span>
<span class="hljs-keyword">val</span> fish = <span class="hljs-number">2</span>
println(fish.times(<span class="hljs-number">6</span>)) <span class="hljs-comment">// Prints: 12</span>
println(fish.div(<span class="hljs-number">10.0</span>)) <span class="hljs-comment">// Prints: 0.2</span>
println(fish.plus(<span class="hljs-number">3</span>)) <span class="hljs-comment">// Prints: 5</span>
println(fish.minus(<span class="hljs-number">3</span>)) <span class="hljs-comment">// Prints: -1</span>

<span class="hljs-comment">// You can use numbers(basic types) as if they were objects</span>
<span class="hljs-comment">// Use primitive &#x27;int&#x27; as an object</span>
<span class="hljs-number">1</span>.toLong() <span class="hljs-comment">// 1</span>
println(<span class="hljs-literal">false</span>.not()) <span class="hljs-comment">// true</span>
</div></code></pre>
<h3 id="boxing">Boxing</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Boxing describes the process of converting a primitive value to an object and unboxing therefore the inverse</span>
<span class="hljs-comment">// All numerical types in Kotlin have a supertype called Number</span>
<span class="hljs-comment">// Store value one in a variable of type Number</span>
<span class="hljs-comment">// It&#x27;ll need to be placed in an object wrapper</span>
<span class="hljs-comment">// This is called boxing</span>
<span class="hljs-keyword">val</span> boxed: Number = <span class="hljs-number">1</span>
     ^       ^      ^
    name    type  value

<span class="hljs-keyword">val</span> num: <span class="hljs-built_in">Int</span> = <span class="hljs-number">2</span>
<span class="hljs-keyword">val</span> dob: <span class="hljs-built_in">Double</span> = <span class="hljs-number">2.0</span>

<span class="hljs-comment">// Both lines do the exact same thing internally</span>
Integer x = <span class="hljs-number">42</span>;
Integer y = Integer.valueOf(<span class="hljs-number">42</span>);

<span class="hljs-comment">// Eventhough this is very handy, it unfortunately leads to a decrease in performance</span>
<span class="hljs-comment">// We can avoid creating these objets wrappers by not storing numbers in objects</span>
<span class="hljs-comment">// There are two types of variables in Kotlin</span>
<span class="hljs-comment">// Changeable &amp; Unchangeable</span>
<span class="hljs-comment">//   var           val</span>

<span class="hljs-comment">// With &quot;val&quot; you can assign value only once</span>
<span class="hljs-keyword">val</span> aquarium = <span class="hljs-number">1</span>
aquarium = <span class="hljs-number">2</span> <span class="hljs-comment">// -&gt; ERROR! cannot be reassigned</span>

<span class="hljs-comment">// You can assign vals;</span>
<span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;string&quot;</span>
<span class="hljs-keyword">val</span> numInt = <span class="hljs-number">1</span>
<span class="hljs-keyword">val</span> numDouble = <span class="hljs-number">1.0</span>
<span class="hljs-keyword">val</span> bool = <span class="hljs-literal">false</span>

<span class="hljs-comment">// With &quot;var&quot; you can assign a value, and then you can change it</span>
<span class="hljs-keyword">var</span> fish = <span class="hljs-number">2</span>
fish = <span class="hljs-number">50</span>
<span class="hljs-comment">// Type is inferred meaning that compiler can figure out the type from the context</span>
<span class="hljs-comment">// Even so the type is inferred, it becomes fixed at compile time,</span>
<span class="hljs-comment">// So you cannot change a type of a varible in kotlin once it&#x27;s type has been determined.</span>
fish = <span class="hljs-string">&quot;Bubbles&quot;</span> <span class="hljs-comment">// ERROR</span>

<span class="hljs-comment">// We can use variables in operations and there is no punctuation at the end</span>
<span class="hljs-keyword">var</span> str = <span class="hljs-number">8</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>
a + str
print(a + str)

<span class="hljs-comment">// Number types won&#x27;t implicitly convert to other types, so you can&#x27;t assign</span>
<span class="hljs-comment">// A short value to a long variable or a byte to an int</span>
<span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Byte</span> = <span class="hljs-number">1</span>
<span class="hljs-keyword">val</span> i: <span class="hljs-built_in">Int</span> = b <span class="hljs-comment">// ERROR Type Mismatch</span>

<span class="hljs-comment">// But you can always assign them by casting like this;</span>
<span class="hljs-keyword">val</span> i: <span class="hljs-built_in">Int</span> = b.toInt()

<span class="hljs-comment">// Kotlin supports underscores in numbers</span>
<span class="hljs-keyword">val</span> oneMillion = <span class="hljs-number">1_000_000</span>
<span class="hljs-keyword">val</span> socialSecurityNumber = <span class="hljs-number">999_99_9999L</span>
<span class="hljs-keyword">val</span> hexBytes = <span class="hljs-number">0xFF_EC_DE_5E</span>
<span class="hljs-keyword">val</span> bytes = <span class="hljs-number">0b11010010_01101001_10010100_100100010</span>

<span class="hljs-comment">// You can speficy long constants in a format that makes sense to you</span>
<span class="hljs-comment">// The type is inferred by Kotlin</span>
</div></code></pre>
<h3 id="nullability">Nullability</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Kotlin helps avoid null pointer exceptions</span>
<span class="hljs-comment">// When you declare a variables type expicitly, by default its value cannot be null</span>
<span class="hljs-keyword">var</span> rocks: <span class="hljs-built_in">Int</span> = <span class="hljs-literal">null</span>

<span class="hljs-comment">// Use the question mark operator to indicate that a variable can be null</span>
<span class="hljs-keyword">var</span> rocks: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>

<span class="hljs-comment">// Whe you have complex data types such as a list, </span>
<span class="hljs-keyword">var</span> lotsOfFish: List&lt;String?&gt; = listOf(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)

<span class="hljs-comment">// You can allow for the list to be null, but if it is not null its elements cannot be null</span>
<span class="hljs-keyword">var</span> evenMoreFish: List&lt;String&gt;? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">var</span> definitelyFish: List&lt;String?&gt;? = <span class="hljs-literal">null</span>

<span class="hljs-comment">// Or you can allow both the list or the elements to be null</span>
definitelyFish = listOf(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)

<span class="hljs-comment">// Samples</span>
<span class="hljs-comment">// Creating List</span>
<span class="hljs-keyword">var</span> names5: List&lt;String&gt; = listOf(<span class="hljs-string">&quot;asd&quot;</span>, <span class="hljs-string">&quot;adsad3&quot;</span>)

<span class="hljs-comment">// Allow list to be null</span>
<span class="hljs-keyword">var</span> names: List&lt;String&gt;? = <span class="hljs-literal">null</span>

<span class="hljs-comment">// Allow list items to be null</span>
<span class="hljs-comment">// But list cannot be null</span>
<span class="hljs-keyword">var</span> names2: List&lt;String?&gt; = listOf()

<span class="hljs-comment">// ERROR, List cannot be null</span>
<span class="hljs-keyword">var</span> names3: List&lt;String?&gt; = <span class="hljs-literal">null</span>

<span class="hljs-comment">// Allow both list items and list itself to be null</span>
<span class="hljs-comment">// But list cannot be null</span>
<span class="hljs-keyword">var</span> names4: List&lt;String?&gt;? = <span class="hljs-literal">null</span>

<span class="hljs-keyword">var</span> a: String = <span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-comment">// Regular initialization means non-null by default</span>
a = <span class="hljs-literal">null</span> <span class="hljs-comment">// compilation error</span>
<span class="hljs-comment">// it&#x27;s guaranteed not to cause an NPE, so you can safely say:</span>
<span class="hljs-keyword">val</span> l = a.length

<span class="hljs-comment">// To allow nulls, you can declare a variable as nullable string, written String?:</span>
<span class="hljs-keyword">var</span> b: String? = <span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-comment">// can be set null</span>
b = <span class="hljs-literal">null</span> <span class="hljs-comment">// ok</span>
<span class="hljs-keyword">val</span> l = b.length <span class="hljs-comment">// error: variable &#x27;b&#x27; can be null</span>
print(b)

<span class="hljs-comment">// List with some null items</span>
<span class="hljs-keyword">var</span> listWithNulls: List&lt;String?&gt; = listOf(<span class="hljs-string">&quot;Kot&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;melo&quot;</span>, <span class="hljs-literal">null</span>)

<span class="hljs-comment">// Checking for null in conditions</span>
<span class="hljs-comment">// Option 1: First, you can explicitly check if b is null, and handle the two options separately:</span>
	<span class="hljs-keyword">val</span> l = <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) b.length <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>
	
<span class="hljs-comment">// Option 2: Safe calls, Your second option is the safe call operator, written &quot;?.&quot;</span>
	<span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;Kotlin&quot;</span>
	<span class="hljs-keyword">val</span> b: String? = <span class="hljs-literal">null</span>
	println(b?.length)
	println(a?.length) <span class="hljs-comment">// Unnecessary safe call</span>
	
<span class="hljs-comment">// This returns &quot;b.length&quot; if &quot;b is not null&quot;, and &quot;null&quot; otherwise. The type of this expression is Int?</span>
<span class="hljs-comment">// &quot;b?.length&quot; is equal to &quot;if (b != null) b.length else -1&quot;</span>

    <span class="hljs-keyword">var</span> b: String? = <span class="hljs-string">&quot;abc&quot;</span>
    <span class="hljs-keyword">val</span> l = <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) b.length <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>
    <span class="hljs-keyword">val</span> l2 = b?.length

    <span class="hljs-comment">// Such a chain returns null if any of the properties in it is null.</span>
    bob?.department?.head?.name

<span class="hljs-comment">// If you want to do an operation on the non-null items</span>
<span class="hljs-comment">// To perform a certain operation only for non-null values, you can use the safe call operator together with let: </span>
<span class="hljs-keyword">val</span> listWithNulls: List&lt;String?&gt; = listOf(<span class="hljs-string">&quot;Kotlin&quot;</span>, <span class="hljs-literal">null</span>)
<span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> listWithNulls) {
    item?.let { println(it) } <span class="hljs-comment">// prints Kotlin and ignores null</span>
}

<span class="hljs-comment">// Print also nulls</span>
<span class="hljs-keyword">var</span> listWithNulls: List&lt;String?&gt; = listOf(<span class="hljs-string">&quot;Genesis&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;melo&quot;</span>, <span class="hljs-literal">null</span>)
print(listWithNulls)
</div></code></pre>
<h3 id="elvis-operator------">Elvis operator  &quot;  ?:  &quot;</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*If the expression to the left of ?: is not null, the elvis operator returns it, otherwise it returns the expression to the right. Note that the right-hand side expression is evaluated only if the left-hand side is null.*/</span>

<span class="hljs-keyword">val</span> l: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) b.length <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>
<span class="hljs-keyword">val</span> l = b?.length ?: -<span class="hljs-number">1</span>

<span class="hljs-comment">/*If the expression to the left of ?: is not null, the elvis operator returns it, otherwise it returns the expression to the right. Note that the right-hand side expression is evaluated only if the left-hand side is null.*/</span>
	
<span class="hljs-keyword">var</span> b: String? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">var</span> l = b?.length ?: -<span class="hljs-number">1</span>
print(l)

<span class="hljs-comment">/*Since throw and return are expressions in Kotlin, they can also be used on the right hand side of the elvis operator. This can be very handy, for example, for checking function arguments:
*/</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(node: <span class="hljs-type">Node</span>)</span></span>: String? {
    <span class="hljs-keyword">val</span> parent = node.getParent() ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    <span class="hljs-keyword">val</span> name = node.getName() ?: <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">&quot;name expected&quot;</span>)
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h3 id="the----operator----not-null-assertion-operator---">The &quot; ! &quot; Operator  &amp;  Not-null Assertion Operator &quot; !! &quot;</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*This is unsafe nullable type (T?) conversion to a non-nullable type (T), !// will throw NullPointerException if the value is null.*/</span>

<span class="hljs-comment">/*The third option is for NPE-lovers: the not-null assertion operator (!!) converts any value to a non-null type and throws an exception if the value is null. You can write b!!, and this will return a non-null value of b (for example, a String in our example) or throw an NPE if b is null:*/</span>

	<span class="hljs-keyword">val</span> l = b!!.length

<span class="hljs-comment">/*Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.*/</span>
</div></code></pre>
<h3 id="safe-casts">Safe casts</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Regular casts may result into a ClassCastException if the object is not of the target type. Another option is to use safe casts that return null if the attempt was not successful:*/</span>

    <span class="hljs-comment">// Safe Casts</span>
    <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;1&quot;</span>
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">5</span>
    <span class="hljs-keyword">var</span> aInt: <span class="hljs-built_in">Int</span>? = a <span class="hljs-keyword">as</span>? <span class="hljs-built_in">Int</span>
    <span class="hljs-keyword">var</span> bInt: <span class="hljs-built_in">Int</span>? = b <span class="hljs-keyword">as</span>? <span class="hljs-built_in">Int</span>
    print(aInt) <span class="hljs-comment">// null</span>
    print(bInt) <span class="hljs-comment">// 5</span>
</div></code></pre>
<h3 id="collections-of-a-nullable-type">Collections of a nullable type</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*If you have a collection of elements of a nullable type and want to filter non-null elements, you can do so by using filterNotNull:*/</span>

<span class="hljs-keyword">val</span> nullableList: List&lt;<span class="hljs-built_in">Int</span>?&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>)
<span class="hljs-keyword">val</span> intList: List&lt;<span class="hljs-built_in">Int</span>&gt; = nullableList.filterNotNull()

<span class="hljs-keyword">var</span> nullableList: List&lt;<span class="hljs-built_in">Int</span>?&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">5</span>)
<span class="hljs-keyword">var</span> nonNullList = nullableList.filterNotNull()
print(nonNullList) <span class="hljs-comment">// Prints: [1, 2, 5]</span>

<span class="hljs-comment">// You can do some cool null testing with the question mark operator saving you the pain of many if else statements</span>

<span class="hljs-comment">// You can check if an object or variable is non null before accessing one of its methods</span>

<span class="hljs-keyword">val</span> fishFoodTreats: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">return</span> fishFoodTreats?.dec() ?: <span class="hljs-number">0</span>

<span class="hljs-keyword">val</span> fishFoodTreats = <span class="hljs-number">5</span>
<span class="hljs-keyword">return</span> fishFoodTreats?.dec() ?: <span class="hljs-number">0</span>
<span class="hljs-comment">// You can also chain null tests in an expression</span>
<span class="hljs-comment">/*If &quot;fishFoodTreats&quot; is not null use a treat and return a new value and otherwise return the value after the colon which is zero*/</span>
</div></code></pre>
<h3 id="practice-time-basic-operations">Practice Time: Basic Operations</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
Solve the following using the operator methods in one line of code.
If you start with 2 fish, and they breed twice, producing 71 offspring the first time, and 233 offspring the second time, and then 13 fish are swallowed by a hungry moray eel, how many fish do you have left? How many aquariums do you need if you can put 30 fish per aquarium?

Hint: You can chain method calls.
Hint: You can call the methods on numbers, and Kotlin will convert them to objects for you.
Bonus question: What is special about all the numbers of fish?*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-number">2</span>.plus(<span class="hljs-number">71</span>).plus(<span class="hljs-number">233</span>).minus(<span class="hljs-number">13</span>).div(<span class="hljs-number">30</span>).plus(<span class="hljs-number">1</span>)
<span class="hljs-comment">// Bonus question: If you&#x27;ve noticed, all fish numbers above are prime.</span>

<span class="hljs-comment">// My One Line Solution</span>
println(((<span class="hljs-number">2</span>.times(<span class="hljs-number">71</span>).plus(<span class="hljs-number">2</span>.times(<span class="hljs-number">233</span>))).minus(<span class="hljs-number">13</span>)).div(<span class="hljs-number">30</span>).plus((<span class="hljs-keyword">if</span> (<span class="hljs-number">595</span>.mod(<span class="hljs-number">30</span>) &gt; <span class="hljs-number">0</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)))

<span class="hljs-comment">// To find how many fishes left</span>
println((<span class="hljs-number">2</span>.times(<span class="hljs-number">71</span>).plus(<span class="hljs-number">2</span>.times(<span class="hljs-number">233</span>))).minus(<span class="hljs-number">13</span>))

<span class="hljs-comment">// To find Aquariums Needed</span>
println(<span class="hljs-number">595</span>.div(<span class="hljs-number">30</span>) + <span class="hljs-keyword">if</span> (<span class="hljs-number">595</span>.mod(<span class="hljs-number">30</span>) &gt; <span class="hljs-number">0</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)
</div></code></pre>
<h3 id="practice-time-variables">Practice Time: Variables</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Create a String variable rainbowColor, set its color value, then change it.
Create a variable blackColor whose value cannot be changed once assigned. Try changing it anyway.*/</span>
<span class="hljs-keyword">var</span> rainbowColor: String = <span class="hljs-string">&quot;green&quot;</span>
rainbowColor = <span class="hljs-string">&quot;blue&quot;</span>

<span class="hljs-keyword">val</span> blackColor: String = <span class="hljs-string">&quot;you cannot change me// I am pure Black!&quot;</span>
blackColor = <span class="hljs-string">&quot;White!&quot;</span>

<span class="hljs-comment">//Alternative</span>
<span class="hljs-keyword">var</span> rainbowColor = <span class="hljs-string">&quot;green&quot;</span>
rainbowColor = <span class="hljs-string">&quot;blue&quot;</span>
<span class="hljs-keyword">val</span> blackColor = <span class="hljs-string">&quot;black&quot;</span>
blackColor = <span class="hljs-string">&quot;white&quot;</span> <span class="hljs-comment">// Error</span>
</div></code></pre>
<h3 id="practice-time-nullability">Practice Time: Nullability</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Try to set rainbowColor to null. Declare two variables, greenColor and blueColor. Use two different ways of setting them to null.</span>

<span class="hljs-keyword">var</span> rainbowColor = <span class="hljs-string">&quot;red&quot;</span>
rainbowColor = <span class="hljs-literal">null</span> <span class="hljs-comment">// Error</span>

<span class="hljs-keyword">var</span> greenColor = <span class="hljs-literal">null</span>
<span class="hljs-keyword">var</span> blueColor: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>
</div></code></pre>
<h3 id="practice-time-nullabilitylists">Practice Time: Nullability/Lists</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Create a list with two elements that are null; do it in two different ways.</span>
<span class="hljs-comment">// Next, create a list where the list is null.</span>
<span class="hljs-comment">// list with two null items</span>
<span class="hljs-keyword">var</span> list = listOf(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>)
<span class="hljs-keyword">var</span> list1: List&lt;<span class="hljs-built_in">Int</span>?&gt; = listOf(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)

<span class="hljs-comment">// The list2 itself is null</span>
<span class="hljs-keyword">var</span> list2: List&lt;<span class="hljs-built_in">Int</span>&gt;? = <span class="hljs-literal">null</span>
</div></code></pre>
<h3 id="practice-time-null-checks">Practice Time: Null Checks</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Create a nullable integer variable called nullTest, and set it to null. Use a null-check that increases the value by one if it&#x27;s not null, otherwise returns 0, and prints the result.</span>
<span class="hljs-comment">// Hint: Use the Elvis operator.</span>

<span class="hljs-keyword">var</span> nullable: <span class="hljs-built_in">Int</span>? = <span class="hljs-literal">null</span>
println(nullable?.inc() ?: <span class="hljs-number">0</span>)
println(nullTest?.inc() ?:<span class="hljs-number">0</span>)
</div></code></pre>
<h3 id="strings">Strings</h3>
<pre><code class="language-kotlin"><div><span class="hljs-string">&quot;Hello Fish&quot;</span> <span class="hljs-comment">// Hello Fish</span>

<span class="hljs-comment">// Concatenation</span>
<span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;fish&quot;</span> <span class="hljs-comment">// hello fish</span>

<span class="hljs-keyword">val</span> numberOfFish = <span class="hljs-number">5</span>
<span class="hljs-keyword">val</span> numberOfPlants = <span class="hljs-number">12</span>

<span class="hljs-string">&quot;I have <span class="hljs-variable">$numberOfFish</span> fish and <span class="hljs-variable">$numberOfPlants</span> plants&quot;</span> <span class="hljs-comment">// I have 5 fish and 12 plants</span>

<span class="hljs-comment">// Here two numbers get added first then the result will be printed</span>
<span class="hljs-string">&quot;I have <span class="hljs-subst">${numberOfFish + numberOfPlants}</span> fish and plants&quot;</span> <span class="hljs-comment">// I have 17 fish and plants</span>

<span class="hljs-keyword">val</span> fish = <span class="hljs-string">&quot;fish&quot;</span>
<span class="hljs-keyword">val</span> plant = <span class="hljs-string">&quot;plant&quot;</span>
println(fish == plant) <span class="hljs-comment">// false</span>
println(fish != plant) <span class="hljs-comment">// true</span>

<span class="hljs-keyword">val</span> A = <span class="hljs-string">&quot;A&quot;</span>
<span class="hljs-keyword">val</span> B = <span class="hljs-string">&quot;Z&quot;</span>
println(A &lt; B) <span class="hljs-comment">// true</span>
println(A &gt; B) <span class="hljs-comment">// false</span>
</div></code></pre>
<h3 id="if-else-blocks">If-Else Blocks</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">val</span> numberOfFish = <span class="hljs-number">50</span>
<span class="hljs-keyword">val</span> numberOfPlants = <span class="hljs-number">23</span>
<span class="hljs-keyword">if</span> (numberOfFish &gt; numberOfPlants) {
    println(<span class="hljs-string">&quot;Good Ratio!&quot;</span>)
} <span class="hljs-keyword">else</span> {
    println(<span class="hljs-string">&quot;unhealthy ratio&quot;</span>)
}
</div></code></pre>
<h3 id="ranges">Ranges</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">val</span> fish = <span class="hljs-number">50</span>
<span class="hljs-comment">// .. -&gt; inclusively 1 &lt;= fish &lt;= 50</span>
<span class="hljs-keyword">if</span> (fish <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">50</span>) {
    println(fish.toString() + <span class="hljs-string">&quot; is in the range 1 &lt;= fish &lt;= 50!&quot;</span>)
}
<span class="hljs-comment">// until -&gt; exclusively 1 &lt;= fish &lt; 50</span>
<span class="hljs-keyword">if</span> (fish <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> until <span class="hljs-number">50</span>) {
    println(fish)
} <span class="hljs-keyword">else</span> {
    println(fish.toString() + <span class="hljs-string">&quot; is not in the range 1 &lt;= fish &lt; 50!&quot;</span>)
}
</div></code></pre>
<h3 id="when">When</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// &quot;when&quot; is the way of switching in Kotlin</span>
<span class="hljs-keyword">val</span> numberOfFish = <span class="hljs-number">50</span>
<span class="hljs-keyword">when</span> (numberOfFish) { 
    <span class="hljs-number">0</span> -&gt; println(<span class="hljs-string">&quot;Empty tank&quot;</span>)
    <span class="hljs-number">50</span> -&gt; println(<span class="hljs-string">&quot;Full tank&quot;</span>)
    <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;Perfect!&quot;</span>)
} <span class="hljs-comment">// Output: Full tank</span>

<span class="hljs-keyword">val</span> numberOfFish = <span class="hljs-number">50</span>
<span class="hljs-keyword">when</span> (numberOfFish) {
    <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">50</span> -&gt; println(<span class="hljs-string">&quot;Full tank&quot;</span>)
} <span class="hljs-comment">// Output: Full tank</span>

<span class="hljs-comment">// Create a string which would contain a * symbol n times.</span>
<span class="hljs-keyword">val</span> str: String = <span class="hljs-string">&quot;*&quot;</span>.repeat(<span class="hljs-number">100</span>)
</div></code></pre>
<h3 id="practice-time">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Create three String variables for trout, haddock, and snapper.</span>
<span class="hljs-comment">// Use a String template to print whether you do or don&#x27;t like to eat these kinds of fish.</span>
<span class="hljs-keyword">var</span> trout: String = <span class="hljs-string">&quot;trout&quot;</span>
<span class="hljs-keyword">var</span> haddock: String = <span class="hljs-string">&quot;haddock&quot;</span>
<span class="hljs-keyword">var</span> snappe: String = <span class="hljs-string">&quot;snappe&quot;</span>
<span class="hljs-keyword">var</span> currentFish = trout
<span class="hljs-keyword">when</span> (currentFish) {
    <span class="hljs-string">&quot;trout&quot;</span> -&gt; println(<span class="hljs-string">&quot;I love it!&quot;</span>)
    <span class="hljs-string">&quot;haddock&quot;</span> -&gt; println(<span class="hljs-string">&quot;I like it&quot;</span>)
    <span class="hljs-string">&quot;snappe&quot;</span> -&gt; println(<span class="hljs-string">&quot;I hate it&quot;</span>)
    <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;That&#x27;s enough fish&quot;</span>)
}

<span class="hljs-keyword">val</span> trout1 = <span class="hljs-string">&quot;trout&quot;</span>
<span class="hljs-keyword">var</span> haddock1 = <span class="hljs-string">&quot;haddock&quot;</span>
<span class="hljs-keyword">var</span> snapper1 = <span class="hljs-string">&quot;snapper&quot;</span>
println(<span class="hljs-string">&quot;I like to eat <span class="hljs-variable">$trout1</span> and <span class="hljs-variable">$snapper1</span>, but not a big fan of <span class="hljs-variable">$haddock1</span>.&quot;</span>)
</div></code></pre>
<h3 id="practice-time-1">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*when statements in Kotlin are like case or switch statements in other languages.
Create a when statement with three comparisons:

If the length of the fishName is 0, print an error message.
If the length is in the range of 3...12, print &quot;Good fish name&quot;.
If it&#x27;s anything else, print &quot;OK fish name&quot;.*/</span>

<span class="hljs-keyword">var</span> fishName = <span class="hljs-string">&quot;Salmon&quot;</span>
<span class="hljs-keyword">when</span> (fishName.length) {
    <span class="hljs-number">0</span> -&gt; println(<span class="hljs-string">&quot;Fish name cannot be empty!&quot;</span>)
    <span class="hljs-keyword">in</span> <span class="hljs-number">3</span>..<span class="hljs-number">12</span> -&gt; println(<span class="hljs-string">&quot;Good fish name&quot;</span>)
    <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;OK fish name&quot;</span>)
}
</div></code></pre>
<h3 id="arrays--loops">Arrays &amp; Loops</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// If val variable value is a reference, then you cannot assign it a different reference later</span>

<span class="hljs-keyword">val</span> myList = mutableListOf(<span class="hljs-string">&quot;tuna&quot;</span>, <span class="hljs-string">&quot;salmon&quot;</span>, <span class="hljs-string">&quot;shark&quot;</span>);
myList = mutableListOf(<span class="hljs-string">&quot;Koi&quot;</span>); <span class="hljs-comment">// ERROR// Cannot be re-assigned</span>

<span class="hljs-comment">// If you&#x27;re referencing something that&#x27;s not immutable(değişmez), it can still change</span>

<span class="hljs-comment">// val only applies to the reference and it doesn&#x27;t make the object it points to immutable</span>

<span class="hljs-comment">// Here we cannot assign a different list in myList but we can manipulate the elemets of the list such as removing/adding an element</span>

<span class="hljs-keyword">val</span> myList = mutableListOf(<span class="hljs-string">&quot;tuna&quot;</span>, <span class="hljs-string">&quot;salmon&quot;</span>, <span class="hljs-string">&quot;shark&quot;</span>);
myList.remove(<span class="hljs-string">&quot;shark&quot;</span>) <span class="hljs-comment">// True</span>
myList.add(<span class="hljs-string">&quot;fish&quot;</span>) <span class="hljs-comment">// True</span>
</div></code></pre>
<h3 id="forwhile-loop-examples">For/While Loop Examples</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">val</span> myList = mutableListOf(<span class="hljs-string">&quot;tuna&quot;</span>, <span class="hljs-string">&quot;salmon&quot;</span>, <span class="hljs-string">&quot;shark&quot;</span>);
<span class="hljs-comment">// Loop through an array</span>
<span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> myList) {
    print(item + <span class="hljs-string">&quot; &quot;</span>) <span class="hljs-comment">// tuna salmon shark </span>
}
<span class="hljs-comment">// Loop through an array With index</span>
<span class="hljs-keyword">for</span> (index <span class="hljs-keyword">in</span> myList.indices) {
    print(myList[index] + <span class="hljs-string">&quot; &quot;</span>) <span class="hljs-comment">// tuna salmon shark </span>
}
<span class="hljs-keyword">for</span> ((index, value) <span class="hljs-keyword">in</span> myList.withIndex()) {
    println(<span class="hljs-string">&quot;the element at <span class="hljs-variable">$index</span> is <span class="hljs-variable">$value</span>&quot;</span>) <span class="hljs-comment">// the element at 0 is tuna...</span>
}
<span class="hljs-comment">//    for (i in array.indices) {</span>
<span class="hljs-comment">//        println(array[i])</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-comment">// To iterate over a range of numbers, use a range expression</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span>) {
<span class="hljs-comment">//        print(i.toString() + &quot; &quot;) /// Alternate</span>
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>) <span class="hljs-comment">// 1 2 3 4 5 </span>
}
<span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>) {
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$c</span> &quot;</span>) <span class="hljs-comment">// a b c d e f g h i j k l m n o p q r s t u v w x y z </span>
}
<span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;z&#x27;</span> downTo <span class="hljs-string">&#x27;a&#x27;</span>) {
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$c</span> &quot;</span>) <span class="hljs-comment">// z y x w v u t s r q p o n m l k j i h g f e d c b a </span>
}
<span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> <span class="hljs-number">10</span> downTo <span class="hljs-number">0</span>) {
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$c</span> &quot;</span>) <span class="hljs-comment">// 10 9 8 7 6 5 4 3 2 1 0 </span>
}
<span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> <span class="hljs-number">10</span> downTo <span class="hljs-number">0</span> step <span class="hljs-number">2</span>) {
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$c</span> &quot;</span>) <span class="hljs-comment">// 10 8 6 4 2 0 </span>
}
<span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> step <span class="hljs-number">2</span>) {
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$c</span> &quot;</span>) <span class="hljs-comment">// 1 3 5 7 9 </span>
}
</div></code></pre>
<h3 id="while-loop">While loop</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>
<span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) {
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$x</span> &quot;</span>) <span class="hljs-comment">// 5 4 3 2 1 </span>
    x--
}
<span class="hljs-comment">// Arrays work pretty much as you&#x27;d expect with some cool additions</span>
<span class="hljs-comment">// Good practice is to prefer using &quot;lists&quot; over &quot;arrays&quot; everywhere except for performance critical parts of your code</span>

<span class="hljs-comment">// It is pretty similar to Java</span>
<span class="hljs-keyword">val</span> l1 = listOf(<span class="hljs-string">&quot;a&quot;</span>)
<span class="hljs-keyword">val</span> l2 = listOf(<span class="hljs-string">&quot;a&quot;</span>)
<span class="hljs-keyword">var</span> x = (l1 == l2) <span class="hljs-comment">// =&gt; true</span>

<span class="hljs-keyword">val</span> a1 = arrayOf(<span class="hljs-string">&quot;a&quot;</span>)
<span class="hljs-keyword">val</span> a2 = arrayOf(<span class="hljs-string">&quot;a&quot;</span>)
<span class="hljs-keyword">var</span> y = (a1 == a2) <span class="hljs-comment">// =&gt; false</span>
</div></code></pre>
<h3 id="listof-vs-mutablelistof">listOf vs mutableListOf</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
List: READ-ONLY
MutableList: READ/WRITE
You can modify a MutableList: change, remove, add... its elements.
In a List you can only read them.

// Prefer MutableList over Array
// The major difference from usage side is that;
-&gt; Arrays have a fixed size (like int [] in C++)
-&gt; MutableList can adjust their size dynamically (like vectors in C++, a.k.a dynamic arrays)
-&gt; Moreover Array is MUTABLE whereas List is not. (List is read-only, Array is not)

// Difference between ArrayList&lt;String&gt;() and mutableListOf&lt;String&gt;() in Kotlin
-&gt; The only difference between the two is communicating your intent :)
-&gt; So, there is no difference, just a convenience method.*/</span>

<span class="hljs-comment">// Create an array</span>
<span class="hljs-keyword">val</span> school = arrayOf(<span class="hljs-string">&quot;fish&quot;</span>, <span class="hljs-string">&quot;tuna&quot;</span>, <span class="hljs-string">&quot;salmon&quot;</span>)

<span class="hljs-comment">// Create Typed array (e.g. integers)</span>
<span class="hljs-keyword">val</span> numbers = intArrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

<span class="hljs-comment">// Error, Type Mismatch</span>
<span class="hljs-keyword">val</span> test = intArrayOf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;foo&quot;</span>)

<span class="hljs-comment">// But you can mix types in Untyped arrays</span>
<span class="hljs-keyword">val</span> mixedArray = arrayOf(<span class="hljs-string">&quot;fish&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">0.0</span>)
<span class="hljs-keyword">for</span> (element <span class="hljs-keyword">in</span> mixedArray) {
    println(element) <span class="hljs-comment">// fish 2 s 0.0 </span>
    <span class="hljs-comment">// print(element.toString() + &quot; &quot;)</span>
}

<span class="hljs-comment">// This does not prints the all elements, it prints the array address instead</span>
<span class="hljs-keyword">val</span> mixedArray = arrayOf(<span class="hljs-string">&quot;fish&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">0.0</span>)
print(mixedArray) <span class="hljs-comment">// [Ljava.lang.Object;@66d3c617</span>

<span class="hljs-comment">// You can use joinToString or forEach, forEachIndexed, Arrays.toString( array )</span>
<span class="hljs-keyword">val</span> mixedArray = arrayOf(<span class="hljs-string">&quot;fish&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">0.0</span>)
print(mixedArray.joinToString()) <span class="hljs-comment">// fish, 2, s, 0.0</span>
mixedArray.forEach { print(<span class="hljs-string">&quot;<span class="hljs-variable">$it</span> &quot;</span>) } <span class="hljs-comment">// fish, 2, s, 0.0</span>
mixedArray.forEachIndexed { index, any -&gt; println(<span class="hljs-string">&quot;<span class="hljs-variable">$any</span> at <span class="hljs-variable">$index</span>&quot;</span>) }
<span class="hljs-comment">// fish at 0 ...</span>
println(Arrays.toString(mixedArray)) <span class="hljs-comment">// [fish, 2, s, 0.0]</span>
</div></code></pre>
<h3 id="nesting-arrays">Nesting Arrays</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// You can nest arrays</span>
<span class="hljs-keyword">val</span> swarm = listOf(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>)
<span class="hljs-comment">// When you put an array within an array, you have an array of arrays</span>
<span class="hljs-comment">// !Not a flattened array of the contents of the two</span>
<span class="hljs-keyword">val</span> bigSwarm = arrayOf(swarm, arrayOf(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>))
println(Arrays.toString(bigSwarm))
println(bigSwarm.asList()) <span class="hljs-comment">// Shorter Printing Array Alternative</span>
<span class="hljs-comment">// Prints:  [[5, 12], [Ljava.lang.String;@452b3a41]</span>

<span class="hljs-comment">// You can nest arrays</span>
<span class="hljs-keyword">val</span> intList = listOf(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>)
<span class="hljs-keyword">val</span> stringList = mutableListOf(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>)
<span class="hljs-comment">// OR this -&gt; val stringList = listOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span>
<span class="hljs-comment">// When you put &quot;LİST or MUTABLELIST&quot; within an array, you have an array of arrays with merged content but &quot;ARRAYS&quot; are passed by ref as shown above example</span>
<span class="hljs-keyword">val</span> bigList = listOf(intList, stringList)
println(bigList.joinToString())
<span class="hljs-comment">// [5, 12], [A, B, C]</span>
</div></code></pre>
<h3 id="create-typed-lists-mutablelists-and-arrays">Create Typed Lists, Mutablelists and Arrays</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">val</span> intList = listOf&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>)
<span class="hljs-keyword">val</span> stringList = listOf&lt;String&gt;(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)

<span class="hljs-comment">// Mutablelists</span>
<span class="hljs-keyword">val</span> intList = mutableListOf&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>)
<span class="hljs-keyword">val</span> stringList = mutableListOf&lt;String&gt;(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)

<span class="hljs-comment">// Array</span>
<span class="hljs-keyword">val</span> intList = arrayOf&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>)
<span class="hljs-keyword">val</span> stringList = arrayOf&lt;String&gt;(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)

<span class="hljs-comment">// Sized array</span>
<span class="hljs-keyword">var</span> table = Array&lt;String&gt;(words.size) {<span class="hljs-string">&quot;&quot;</span>}
<span class="hljs-keyword">val</span> literals = arrayOf&lt;String&gt;(<span class="hljs-string">&quot;January&quot;</span>, <span class="hljs-string">&quot;February&quot;</span>, <span class="hljs-string">&quot;March&quot;</span>)

<span class="hljs-comment">// Create 2D Array</span>
<span class="hljs-keyword">val</span> grid = Array(rows) { Array(cols) { Any() } }

<span class="hljs-comment">//String[] in Java equivalent Array&lt;String&gt; in Kotlin </span>
<span class="hljs-comment">//eg.</span>
<span class="hljs-keyword">var</span> array1 : Array&lt;String?&gt; = emptyArray()
<span class="hljs-keyword">var</span> array2: Array&lt;String?&gt; = arrayOfNulls(<span class="hljs-number">4</span>)
<span class="hljs-keyword">var</span> array3: Array&lt;String&gt; = arrayOf(<span class="hljs-string">&quot;Mashroom&quot;</span>, <span class="hljs-string">&quot;Kitkat&quot;</span>, <span class="hljs-string">&quot;Oreo&quot;</span>, <span class="hljs-string">&quot;Lolipop&quot;</span>)

<span class="hljs-keyword">val</span> num = arrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)   <span class="hljs-comment">//implicit type declaration</span>
<span class="hljs-keyword">val</span> num = arrayOf&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">//explicit type declaration</span>

<span class="hljs-comment">// Or you can also create typed lists, arrays, mutable lists</span>
<span class="hljs-keyword">val</span> intList = listOf&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>)
<span class="hljs-keyword">val</span> listSample: List&lt;<span class="hljs-built_in">Int</span>&gt; = listOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> mutableListSample: MutableList&lt;<span class="hljs-built_in">Int</span>&gt; = mutableListOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> stringList = listOf&lt;String&gt;(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)
<span class="hljs-keyword">val</span> stringListSample: List&lt;String&gt; = listOf&lt;String&gt;(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)
<span class="hljs-keyword">var</span> initList = List(<span class="hljs-number">4</span>){<span class="hljs-string">&quot;s&quot;</span>} <span class="hljs-comment">// {&quot;s&quot;, &quot;s&quot;, &quot;s&quot;, &quot;s&quot;}</span>

<span class="hljs-comment">// Arrays</span>
<span class="hljs-keyword">val</span> intArray = arrayOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> intArray2: Array&lt;<span class="hljs-built_in">Int</span>&gt; = arrayOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> intArray3 = intArrayOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> charArray = charArrayOf(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)
<span class="hljs-keyword">val</span> intArray = arrayOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> intArray2: Array&lt;<span class="hljs-built_in">Int</span>&gt; = arrayOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> intArray3 = intArrayOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> charArray = charArrayOf(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)
<span class="hljs-keyword">val</span> stringArray = arrayOf(<span class="hljs-string">&quot;genesis&quot;</span>, <span class="hljs-string">&quot;melo&quot;</span>)
<span class="hljs-keyword">val</span> stringArray2: Array&lt;String&gt; = arrayOf(<span class="hljs-string">&quot;genesis&quot;</span>, <span class="hljs-string">&quot;melo&quot;</span>)
<span class="hljs-keyword">val</span> stringOrNulls = arrayOfNulls&lt;String&gt;(<span class="hljs-number">5</span>) <span class="hljs-comment">// returns Array&lt;String?&gt;</span>
<span class="hljs-keyword">val</span> stringOrNulls2: Array&lt;String?&gt; = arrayOf(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>)<span class="hljs-comment">// returns Array&lt;String?&gt;</span>
<span class="hljs-keyword">var</span> emptyStringArray: Array&lt;String&gt; = emptyArray()
<span class="hljs-keyword">var</span> emptyStringArray2: Array&lt;String&gt; = arrayOf()
<span class="hljs-keyword">var</span> sizedEmptyArray = Array(<span class="hljs-number">4</span>){<span class="hljs-string">&quot;s&quot;</span>} <span class="hljs-comment">// {&quot;s&quot;, &quot;s&quot;, &quot;s&quot;, &quot;s&quot;}</span>

<span class="hljs-comment">// In this line, we create an array from a range of numbers.</span>
<span class="hljs-keyword">val</span> nums3 = IntArray(<span class="hljs-number">5</span>, { i -&gt; i * <span class="hljs-number">2</span> + <span class="hljs-number">3</span>})
<span class="hljs-comment">// This line creates an array with IntArray. It takes the number of elements and a factory function as parameters.</span>
<span class="hljs-comment">// This is the output. </span>
<span class="hljs-comment">/*
[1, 2, 3, 4, 5]
[3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
[3, 5, 7, 9, 11]
*/</span>

<span class="hljs-comment">// You can read this as initialize an array of 5 elements, assign each item to its index times two</span>
<span class="hljs-keyword">val</span> array = Array(<span class="hljs-number">5</span>) {it * <span class="hljs-number">2</span>}
<span class="hljs-comment">// OR -&gt; val array = List(5) {it * 2}</span>
println(array.joinToString()) <span class="hljs-comment">// 0, 2, 4, 6, 8</span>

<span class="hljs-keyword">val</span> list = List(<span class="hljs-number">5</span>){ it.times(<span class="hljs-number">2</span>) } <span class="hljs-comment">// Creates List: [0, 2, 4, 6, 8]</span>

<span class="hljs-keyword">val</span> array = Array&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">5</span>) { e -&gt; <span class="hljs-keyword">if</span> (e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> }
println(array.asList())

<span class="hljs-keyword">val</span> array = List&lt;String&gt;(<span class="hljs-number">5</span>) { e -&gt; <span class="hljs-keyword">if</span> (e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-string">&quot;even&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;<span class="hljs-variable">$e</span>&quot;</span> }
println(array.joinToString()) <span class="hljs-comment">// Prints: even, 1, even, 3, even</span>

<span class="hljs-comment">// Loop array with indices</span>
<span class="hljs-keyword">val</span> swarm = listOf(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>)

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until swarm.size) {
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>) <span class="hljs-comment">// 0 1 2 3 </span>
}

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..swarm.size - <span class="hljs-number">1</span>) {
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>) <span class="hljs-comment">// 0 1 2 3 </span>
}

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> swarm.indices) {
    print(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span> &quot;</span>) <span class="hljs-comment">// 0 1 2 3 </span>
}

<span class="hljs-keyword">for</span> (indexValuePair <span class="hljs-keyword">in</span> swarm.withIndex()) {
    print(<span class="hljs-string">&quot;index: <span class="hljs-subst">${indexValuePair.index}</span>, value: <span class="hljs-subst">${indexValuePair.value}</span>\n&quot;</span>)
} <span class="hljs-comment">// Prints:  index: 0, value: 5</span>
</div></code></pre>
<h3 id="quiz">Quiz</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Read the code below, and then select the correct array initialization that will display the corresponding output.</span>
<span class="hljs-keyword">val</span> array = <span class="hljs-comment">// initalize array here</span>
<span class="hljs-keyword">val</span> sizes = arrayOf(<span class="hljs-string">&quot;byte&quot;</span>, <span class="hljs-string">&quot;kilobyte&quot;</span>, <span class="hljs-string">&quot;megabyte&quot;</span>, <span class="hljs-string">&quot;gigabyte&quot;</span>,
    <span class="hljs-string">&quot;terabyte&quot;</span>, <span class="hljs-string">&quot;petabyte&quot;</span>, <span class="hljs-string">&quot;exabyte&quot;</span>)
<span class="hljs-keyword">for</span> ((i, value) <span class="hljs-keyword">in</span> array.withIndex()) {
   println(<span class="hljs-string">&quot;1 <span class="hljs-subst">${sizes[i]}</span> = <span class="hljs-subst">${value.toLong()}</span> bytes&quot;</span>)
}

<span class="hljs-comment">// Output:</span>
<span class="hljs-number">1</span> byte = <span class="hljs-number">1</span> bytes
<span class="hljs-number">1</span> kilobyte = <span class="hljs-number">1000</span> bytes
<span class="hljs-number">1</span> megabyte = <span class="hljs-number">1000000</span> bytes
<span class="hljs-number">1</span> gigabyte = <span class="hljs-number">1000000000</span> bytes
<span class="hljs-number">1</span> terabyte = <span class="hljs-number">1000000000000</span> bytes
<span class="hljs-number">1</span> petabyte = <span class="hljs-number">1000000000000000</span> bytes
<span class="hljs-number">1</span> exabyte = <span class="hljs-number">1000000000000000000</span> bytes

<span class="hljs-comment">// Answer / Solution Code:</span>
<span class="hljs-keyword">val</span> array = Array(<span class="hljs-number">7</span>){ <span class="hljs-number">1000.0</span>.pow(it) }
<span class="hljs-comment">// Notice how we had to use the double value 1000.0 and not just 1000 to be able to use the &quot;pow&quot; function.</span>
</div></code></pre>
<h3 id="quiz-1">Quiz</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/* Which of these options are good reasons to explicitly make a list immutable? There may be more than 1 correct answer.
-&gt; It reduces errors in general.
-&gt; Prevents accidental changing of objects that were meant to be unchangeable.
-&gt; In a multi-threaded environment, makes the variable thread safe, because once it has been assigned by the initial thread, no thread can change it.*/</span>

<span class="hljs-comment">// Answer: Immutable variables are the safest option when you know that a variable will never need to change values.</span>
</div></code></pre>
<h3 id="practice-time-2">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Looping over arrays and lists is a fundamental technique that has a lot of flexibility in Kotlin. Let&#x27;s practice.

	Basic example
Create an integer array of numbers called numbers, from 11 to 15.
Create an empty mutable list for Strings.
Write a for loop that loops over the array and adds the string representation of each number to the list.

	Challenge example
How can you use a for loop to create (a list of) the numbers between 0 and 100 that are divisible by 7?*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-keyword">var</span> list3 : MutableList&lt;<span class="hljs-built_in">Int</span>&gt; = mutableListOf()
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> step <span class="hljs-number">7</span>) list3.add(i)
print(list3)
[<span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">14</span>, <span class="hljs-number">21</span>, <span class="hljs-number">28</span>, <span class="hljs-number">35</span>, <span class="hljs-number">42</span>, <span class="hljs-number">49</span>, <span class="hljs-number">56</span>, <span class="hljs-number">63</span>, <span class="hljs-number">70</span>, <span class="hljs-number">77</span>, <span class="hljs-number">84</span>, <span class="hljs-number">91</span>, <span class="hljs-number">98</span>]

<span class="hljs-comment">// OR</span>

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> step <span class="hljs-number">7</span>) println(i.toString() + <span class="hljs-string">&quot; - &quot;</span>)

<span class="hljs-comment">// My Solution</span>
<span class="hljs-keyword">val</span> numbers = Array&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">5</span>) { it + <span class="hljs-number">11</span> }
println(numbers.asList())
<span class="hljs-keyword">var</span> mutableList = mutableListOf&lt;String&gt;()
<span class="hljs-keyword">for</span> (number <span class="hljs-keyword">in</span> numbers) {
    mutableList.add(number.toString())
}
println(mutableList)
<span class="hljs-comment">// Challange Example</span>
<span class="hljs-keyword">for</span> (number <span class="hljs-keyword">in</span> <span class="hljs-number">7</span>..<span class="hljs-number">100</span> step <span class="hljs-number">7</span>) {
    println(<span class="hljs-string">&quot;<span class="hljs-variable">$number</span> &quot;</span>)
}
</div></code></pre>
<h3 id="kotlin-lists-from-jetbrains-official-video">Kotlin Lists (from Jetbrains Official Video)</h3>
<pre><code class="language-kotlin"><div>listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// [1, 2, 3]</span>

<span class="hljs-keyword">val</span> l2 = List(<span class="hljs-number">5</span>){ <span class="hljs-string">&quot;No. <span class="hljs-variable">$it</span>&quot;</span> }
<span class="hljs-keyword">val</span> l3 = List(<span class="hljs-number">5</span>){ idx -&gt; <span class="hljs-string">&quot;No. <span class="hljs-variable">$idx</span>&quot;</span> }
<span class="hljs-comment">// [No. 0, No. 1, No. 2, No. 3, No. 4]</span>

<span class="hljs-keyword">val</span> l4 = <span class="hljs-string">&quot;word-salad&quot;</span>.toList()
<span class="hljs-comment">// [w, o, r, d, -, s, a, l, a, d]</span>

<span class="hljs-keyword">val</span> m1 = mapOf(
	<span class="hljs-number">1</span> to <span class="hljs-string">&quot;Gold&quot;</span>,
	<span class="hljs-number">2</span> to <span class="hljs-string">&quot;Silver&quot;</span>,
	<span class="hljs-number">3</span> to <span class="hljs-string">&quot;Bronze&quot;</span>
).toList()
<span class="hljs-comment">// [(1, Gold), (2, Silver), (3, Bronze)]</span>

generateSequence {
	Random.nextInt(<span class="hljs-number">100</span>).takeIf { it &gt; <span class="hljs-number">30</span> }
}.toList()
<span class="hljs-comment">// [45, 75, 74, 31, 54, 36, 63]</span>

(<span class="hljs-number">0</span>..<span class="hljs-number">5</span>).toList()
<span class="hljs-comment">// [0, 1, 2, 3, 4, 5]</span>

<span class="hljs-keyword">val</span> mutList = mutableListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> otherList = mutList.toList()

mutList[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>

mutList
<span class="hljs-comment">// [5, 2, 3]</span>

otherList
<span class="hljs-comment">// [1, 2, 3]</span>

<span class="hljs-keyword">val</span> myList = listOf(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>)
myList.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>)
myList[<span class="hljs-number">0</span>]

myList.getOrNull(<span class="hljs-number">3</span>)
<span class="hljs-keyword">val</span> test = myList.getOrElse(<span class="hljs-number">3</span>) {
	println(<span class="hljs-string">&quot;There is no index <span class="hljs-variable">$it</span>&quot;</span>)
	<span class="hljs-string">&quot;:(&quot;</span>
}
<span class="hljs-comment">// There is no index 3</span>
<span class="hljs-comment">// :(</span>

<span class="hljs-keyword">val</span> listOfNullableItems = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>)
<span class="hljs-comment">// Elvis operator checks if item at index 2 null, if it is null it returns 0,</span>
<span class="hljs-comment">// returns the element at index 2 otherwise</span>
<span class="hljs-keyword">val</span> item = listOfNullableItems[<span class="hljs-number">2</span>] ?: <span class="hljs-number">0</span>

<span class="hljs-keyword">val</span> myList1 = listOf(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>)
myList1.slice(listOf(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>))
<span class="hljs-comment">// [a, c, e]</span>

myList1.slice(<span class="hljs-number">0</span>..<span class="hljs-number">3</span>)
<span class="hljs-comment">// [a, b, c, d]</span>

myList1.slice(<span class="hljs-number">0</span>..myList1.lastIndex step <span class="hljs-number">2</span>)
<span class="hljs-comment">// [a, c, e]</span>

myList1.slice(<span class="hljs-number">2</span> downTo <span class="hljs-number">0</span>)
<span class="hljs-comment">// [c, b, a]</span>

mutableListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// [1, 2, 3]</span>

(<span class="hljs-number">0</span>..<span class="hljs-number">5</span>).toMutableList()
<span class="hljs-comment">// [0, 1, 2, 3, 4, 5]</span>

listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).toMutableList()
<span class="hljs-comment">// [1, 2, 3]</span>

<span class="hljs-keyword">val</span> m = mutableListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
m.add(<span class="hljs-number">4</span>)
m += <span class="hljs-number">4</span>
<span class="hljs-comment">// [1, 2, 3, 4, 4]</span>

m.add(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)
<span class="hljs-comment">// [1, 2, 10, 3, 4, 4]</span>

<span class="hljs-comment">// Append a list to another list</span>
m += listOf(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)
<span class="hljs-comment">// [1, 2, 10, 3, 4, 4, 5, 6, 7]</span>

<span class="hljs-keyword">val</span> mList = mutableListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
mList -= <span class="hljs-number">3</span>
mList.remove(<span class="hljs-number">3</span>)
<span class="hljs-comment">// [1, 2, 3, 4]</span>

<span class="hljs-comment">// Removes all instances of given elements from the mList</span>
mList -= listOf(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)
<span class="hljs-comment">// [2, 3]</span>

mList.removeAt(<span class="hljs-number">1</span>)
<span class="hljs-comment">// [2]</span>

mList[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>
<span class="hljs-comment">// [5]</span>

<span class="hljs-keyword">val</span> fruits = mutableListOf(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Apricot&quot;</span>, <span class="hljs-string">&quot;Cherry&quot;</span>)
fruits.fill(<span class="hljs-string">&quot;sugar&quot;</span>)
<span class="hljs-comment">// [sugar, sugar, sugar]</span>
fruits.clear()
<span class="hljs-comment">// []</span>

<span class="hljs-comment">// The following will create a new list and return it</span>
<span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>)
list.shuffled()
<span class="hljs-comment">// [5, 3, 4, 1, 1, 9]</span>

list.sorted()
<span class="hljs-comment">// [1, 1, 3, 4, 5, 9]</span>

list.reversed()
<span class="hljs-comment">// [9, 5, 1, 4, 1, 3]</span>

<span class="hljs-comment">// The following will do the operations &quot;in-place&quot; without creating a new list</span>
<span class="hljs-keyword">val</span> mm = list.toMutableList()
mm.shuffle()
<span class="hljs-comment">// [5, 3, 4, 1, 1, 9]</span>

mm.sort()
<span class="hljs-comment">// [1, 1, 3, 4, 5, 9]</span>

mm.reverse()
<span class="hljs-comment">// [9, 5, 1, 4, 1, 3]</span>

<span class="hljs-keyword">val</span> numbers = mutableListOf(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span> ,<span class="hljs-number">9</span>)
numbers.removeAll { it &lt; <span class="hljs-number">5</span> }
<span class="hljs-comment">// [5, 9]</span>

<span class="hljs-keyword">val</span> letters = mutableListOf(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>)
letters.retainAll { it.isLetter() }
<span class="hljs-comment">// [a, b, d]</span>

<span class="hljs-keyword">val</span> letters2 = mutableListOf(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>)
<span class="hljs-keyword">val</span> sub = letters2.subList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [ inclusive, exclusive )</span>
<span class="hljs-comment">// [B, C, D]</span>

<span class="hljs-comment">// There is only one list here, sub list is just a reference, a view of letters2</span>
<span class="hljs-comment">// And they are reflecting each other</span>
letters2[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Z&quot;</span>
println(sub)
<span class="hljs-comment">// [Z, C, D]</span>

sub[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;MM&quot;</span>
println(letters2)
<span class="hljs-comment">// [A, Z, C, MM]</span>

sub.fill(<span class="hljs-string">&quot;FF&quot;</span>)
println(letters2)
<span class="hljs-comment">// [A, FF, FF, FF]</span>

sub.clear()
println(letters2)
<span class="hljs-comment">// [A]</span>

letters2.clear()
<span class="hljs-comment">//	println(sub) // ERROR// Because there is no more original list</span>

<span class="hljs-keyword">val</span> nums = mutableListOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> ,<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-comment">// A reversed view of nums</span>
<span class="hljs-keyword">val</span> smun = nums.asReversed()

println(smun)
<span class="hljs-comment">// [4, 3, 2, 1]</span>

nums[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span>
println(smun)
<span class="hljs-comment">// [4, 3, 99, 1]</span>

smun[<span class="hljs-number">2</span>] = -<span class="hljs-number">1</span>
println(nums)
<span class="hljs-comment">// [1, -1, 3, 4]</span>
</div></code></pre>
<h2 id="l3">Lesson 3 | Functions</h2>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// A function like main returns a type &quot;UNIT&quot; which is Kotlin&#x27;s way of saying no value</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    println(<span class="hljs-string">&quot;Hello, world!&quot;</span>)
    println(test()) <span class="hljs-comment">// kotlin.Unit</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> {
}
</div></code></pre>
<h3 id="practice-time-3">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Basic Task

Create a new Kotlin file.
Copy and paste the main() function from Hello World into the file.
Create a new function, dayOfWeek().
In the body of the function, print &quot;What day is it today?&quot;
Call dayOfWeek() from main().
Run your program.
Task List

Extended Task

In the body of the dayOfWeek() function, answer the question by printing the current day of the week.

Hints
You can use Java libraries (java.util) from Kotlin. For example, to get the day of the week:
Calendar.getInstance().get(Calendar.DAY_OF_WEEK) 
Type in the code, then press Option + Enter in Mac, or Alt + Enter in Windows, over the red Calendar class to import the library.
Use a when statement*/</span>

<span class="hljs-comment">// Answer:</span>
<span class="hljs-keyword">import</span> java.util.*
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    dayOfWeek()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dayOfWeek</span><span class="hljs-params">()</span></span> {
    println(<span class="hljs-string">&quot;What day is it today?&quot;</span>)
    <span class="hljs-keyword">val</span> day = Calendar.DAY_OF_WEEK
    println(<span class="hljs-keyword">when</span>(day) {
        <span class="hljs-number">1</span> -&gt; <span class="hljs-string">&quot;Monday&quot;</span>
        <span class="hljs-number">2</span> -&gt; <span class="hljs-string">&quot;Tuesday&quot;</span>
        <span class="hljs-number">3</span> -&gt; <span class="hljs-string">&quot;Wednesday&quot;</span>
        <span class="hljs-number">4</span> -&gt; <span class="hljs-string">&quot;Thursday&quot;</span>
        <span class="hljs-number">5</span> -&gt; <span class="hljs-string">&quot;Friday&quot;</span>
        <span class="hljs-number">6</span> -&gt; <span class="hljs-string">&quot;Saturday&quot;</span>
        <span class="hljs-number">7</span> -&gt; <span class="hljs-string">&quot;Sunday&quot;</span>
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;Time has stopped&quot;</span>
    })
}
</div></code></pre>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Run -&gt; Edit COnfigurations -&gt; Program Args: Kotlin</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    println(<span class="hljs-string">&quot;Hello, <span class="hljs-subst">${ args[<span class="hljs-number">0</span>] }</span>&quot;</span>) <span class="hljs-comment">// Hello, Kotlin</span>
}

<span class="hljs-comment">// Fetching the first element of an array is EXPRESSION</span>
<span class="hljs-comment">// not a value, that why we used ${ args[0] }</span>

<span class="hljs-comment">// In Kotlin almost everthing has a value, even if that value is unit</span>
<span class="hljs-comment">// Everything in Kotlin is an expression</span>
<span class="hljs-comment">// You can use the value of an &quot;if&quot; expression right away</span>

<span class="hljs-keyword">val</span> isUnit = println(<span class="hljs-string">&quot;This is an expression&quot;</span>)
println(isUnit)
<span class="hljs-comment">// This is an expression</span>
<span class="hljs-comment">// kotlin.Unit</span>

<span class="hljs-keyword">val</span> temperature = <span class="hljs-number">10</span>
<span class="hljs-keyword">val</span> isHot = <span class="hljs-keyword">if</span> (temperature &gt; <span class="hljs-number">50</span>) <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">false</span>
println(isHot) <span class="hljs-comment">// false</span>

<span class="hljs-keyword">val</span> message = <span class="hljs-string">&quot;You are <span class="hljs-subst">${ if (temperature &gt; <span class="hljs-number">50</span>) <span class="hljs-string">&quot;fried&quot;</span> else <span class="hljs-string">&quot;safe&quot;</span> }</span> fish&quot;</span>
println(message) <span class="hljs-comment">// You are safe fish</span>
</div></code></pre>
<h3 id="exercise-greetings-kotlin">Exercise: Greetings, Kotlin</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Create a main() function that takes an argument representing the time in 24-hour format
(values between and including 0 -&gt; 23).

In the main() function, check if the time is before midday (&lt;12), then print &quot;Good morning, Kotlin&quot;; otherwise, print &quot;Good night, Kotlin&quot;.

Notes:
Remember that all main() function arguments are Strings, so you will have to convert this argument to an Int before you can apply the check.

Advanced
Try to use Kotlin&#x27;s string templates to do this in 1 line.*/</span>

<span class="hljs-comment">// Your reflection</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    println(<span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>].toInt() &lt; <span class="hljs-number">12</span>) <span class="hljs-string">&quot;Good morning, Kotlin&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Good night, Kotlin&quot;</span>)
}

<span class="hljs-comment">/*Things to think about
There are multiple ways you can do this in Kotlin. Make sure you test your code in IntelliJ with multiple values.

Here&#x27;s one way to do it:*/</span>

<span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>].toInt() &lt; <span class="hljs-number">12</span>) println(<span class="hljs-string">&quot;Good morning, Kotlin&quot;</span>)
<span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;Good night, Kotlin&quot;</span> )

<span class="hljs-comment">// OR</span>

println(<span class="hljs-string">&quot;<span class="hljs-subst">${if (args[<span class="hljs-number">0</span>].toInt() &lt; <span class="hljs-number">12</span>) <span class="hljs-string">&quot;Good morning, Kotlin&quot;</span> else <span class="hljs-string">&quot;Good night, Kotlin&quot;</span>}</span>&quot;</span>)

<span class="hljs-comment">// CTRL + ALT + L  -&gt; Indent File</span>

<span class="hljs-comment">// Repeat an action x times</span>
repeat(<span class="hljs-number">10</span>) { i -&gt;
    println(<span class="hljs-string">&quot;This line will be printed 10 times&quot;</span>)
    println(<span class="hljs-string">&quot;We are on the <span class="hljs-subst">${i + <span class="hljs-number">1</span>}</span>. loop iteration&quot;</span>)
}

<span class="hljs-comment">// Greets three times</span>
repeat(<span class="hljs-number">3</span>) {
    println(<span class="hljs-string">&quot;Hello&quot;</span>)
}

<span class="hljs-comment">// Greets with an index</span>
repeat(<span class="hljs-number">3</span>) { index -&gt;
    println(<span class="hljs-string">&quot;Hello with index <span class="hljs-variable">$index</span>&quot;</span>)
}
</div></code></pre>
<h3 id="practice-time-4">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">import</span> kotlin.random.Random
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;*&quot;</span>.repeat(<span class="hljs-number">10</span>) <span class="hljs-comment">// **********</span>
    println(str)
    <span class="hljs-comment">// Repeat an action 10 times</span>
    repeat (<span class="hljs-number">10</span>) { index -&gt;
        println(<span class="hljs-string">&quot;<span class="hljs-subst">${Random.nextInt(<span class="hljs-number">7</span>)}</span> index: <span class="hljs-variable">$index</span>&quot;</span>)
    }
    feedTheFish()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">feedTheFish</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> day = randomDay()
    <span class="hljs-keyword">val</span> food = <span class="hljs-string">&quot;pellets&quot;</span>
    println(<span class="hljs-string">&quot;Today is <span class="hljs-variable">$day</span> and the fish eat <span class="hljs-variable">$food</span>&quot;</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">randomDay</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">val</span> week = listOf(
        <span class="hljs-string">&quot;Monday&quot;</span>,
        <span class="hljs-string">&quot;Tuesday&quot;</span>,
        <span class="hljs-string">&quot;Wednesday&quot;</span>,
        <span class="hljs-string">&quot;Thursday&quot;</span>,
        <span class="hljs-string">&quot;Friday&quot;</span>,
        <span class="hljs-string">&quot;Saturday&quot;</span>,
        <span class="hljs-string">&quot;Sunday&quot;</span>
    )
    <span class="hljs-keyword">return</span> week[Random.nextInt(<span class="hljs-number">7</span>)]
}
</div></code></pre>
<h3 id="practice-time-5">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Create a program with a function that returns a fortune cookie message that you can print.

Create a main() function.
From the main() function, call a function, getFortuneCookie(), that returns a String.
Create a getFortuneCookie() function that takes no arguments and returns a String.
In the body of getFortuneCookie(), create a list of fortunes. Here are some ideas:

&quot;You will have a great day!&quot;
&quot;Things will go well for you today.&quot;
&quot;Enjoy a wonderful day of success.&quot;
&quot;Be humble and all will turn out well.&quot;
&quot;Today is a good day for exercising restraint.&quot;
&quot;Take it easy and enjoy life!&quot;
&quot;Treasure your friends because they are your greatest fortune.&quot;
Below the list, print: &quot;Enter your birthday: &quot;

Hint: Use print(), not println()
Create a variable, birthday.
Read the user&#x27;s input form the standard input and assign it to birthday. If there is no valid input, set birthday to 1.
Hint: Use readLine() to read a line of input (completed with Enter) as a String.
Hint: In Kotlin, you can use toIntOrNull() to convert a number as a String to an Integer numeric. If the user enters &quot;&quot;, toIntOrNull returns null.
Hint: Check for null using the ? operator and use the ?: operator to handle the null case.
Divide the birthday by the number of fortunes, and use the remainder as the index for the fortune to return.
Return the fortune.
In main(), print: &quot;Your fortune is: &quot;, followed by the fortune string.
Extra practice:
Use a for loop to run the program 10 times, or until the &quot;Take it easy&quot; fortune has been selected.*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    println(<span class="hljs-string">&quot;\nYour fortune is: <span class="hljs-subst">${getFortuneCookie()}</span>&quot;</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getFortuneCookie</span><span class="hljs-params">()</span></span> : String {
    <span class="hljs-keyword">val</span> fortunes = listOf( <span class="hljs-string">&quot;You will have a great day!&quot;</span>,
      <span class="hljs-string">&quot;Things will go well for you today.&quot;</span>,
      <span class="hljs-string">&quot;Enjoy a wonderful day of success.&quot;</span>,
      <span class="hljs-string">&quot;Be humble and all will turn out well.&quot;</span>,
      <span class="hljs-string">&quot;Today is a good day for exercising restraint.&quot;</span>,
      <span class="hljs-string">&quot;Take it easy and enjoy life!&quot;</span>,
      <span class="hljs-string">&quot;Treasure your friends, because they are your greatest fortune.&quot;</span>)
    print(<span class="hljs-string">&quot;\nEnter your birthday: &quot;</span>)
    <span class="hljs-keyword">val</span> birthday = readLine()?.toIntOrNull() ?: <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> fortunes[birthday.rem(fortunes.size)]
}

<span class="hljs-comment">// Extra Practice</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    <span class="hljs-keyword">var</span> fortune: String
    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span>) {
        fortune = getFortuneCookie()
        println(<span class="hljs-string">&quot;\nYour fortune is: <span class="hljs-variable">$fortune</span>&quot;</span>)
        <span class="hljs-keyword">if</span> (fortune.contains(<span class="hljs-string">&quot;Take it easy&quot;</span>)) <span class="hljs-keyword">break</span>
    }
}

<span class="hljs-comment">// My Solution</span>
<span class="hljs-keyword">import</span> kotlin.random.Random
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    <span class="hljs-comment">// OR -&gt; for (i in 1..10) { ... }</span>
    repeat (<span class="hljs-number">10</span>) {
        <span class="hljs-keyword">val</span> fortune = getFortuneCookie()
        println(<span class="hljs-string">&quot;Your fortune is: <span class="hljs-subst">${fortune.first}</span>&quot;</span>)
        <span class="hljs-keyword">if</span> (fortune.second == <span class="hljs-number">5</span>) {
            <span class="hljs-keyword">return</span>
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getFortuneCookie</span><span class="hljs-params">()</span></span>: Pair&lt;String, <span class="hljs-built_in">Int</span>&gt; {
    <span class="hljs-keyword">val</span> fortunes = listOf(
        <span class="hljs-string">&quot;You will have a great day!&quot;</span>,
        <span class="hljs-string">&quot;Things will go well for you today.&quot;</span>,
        <span class="hljs-string">&quot;Enjoy a wonderful day of success.&quot;</span>,
        <span class="hljs-string">&quot;Be humble and all will turn out well.&quot;</span>,
        <span class="hljs-string">&quot;Today is a good day for exercising restraint.&quot;</span>,
        <span class="hljs-string">&quot;Take it easy and enjoy life!&quot;</span>,
        <span class="hljs-string">&quot;Treasure your friends because they are your greatest fortune.&quot;</span>
    )
    print(<span class="hljs-string">&quot;Enter your birthday: &quot;</span>)
    <span class="hljs-keyword">var</span> birthday: String = readLine() ?: <span class="hljs-string">&quot;1&quot;</span>
    <span class="hljs-keyword">val</span> selectedFortuneIndex = birthday.toInt().rem(fortunes.size)
    <span class="hljs-keyword">return</span> Pair(fortunes[ selectedFortuneIndex ], selectedFortuneIndex)
}
</div></code></pre>
<h3 id="practice-time--fish-food">Practice Time | Fish Food</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">import</span> java.time.MonthDay
<span class="hljs-keyword">import</span> kotlin.random.Random

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    repeat (<span class="hljs-number">10</span>) { index -&gt;
        feedTheFish()
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fishFood</span><span class="hljs-params">(day: <span class="hljs-type">String</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (day) {
        <span class="hljs-string">&quot;Monday&quot;</span> -&gt; <span class="hljs-string">&quot;flakes&quot;</span>
        <span class="hljs-string">&quot;Tuesday&quot;</span>-&gt; <span class="hljs-string">&quot;redworms&quot;</span>
        <span class="hljs-string">&quot;Wednesday&quot;</span> -&gt; <span class="hljs-string">&quot;granules&quot;</span>
        <span class="hljs-string">&quot;Thursday&quot;</span> -&gt; <span class="hljs-string">&quot;mosquitoes&quot;</span>
        <span class="hljs-string">&quot;Friday&quot;</span> -&gt; <span class="hljs-string">&quot;plankton&quot;</span>
        <span class="hljs-string">&quot;Saturday&quot;</span> -&gt; <span class="hljs-string">&quot;lettuce&quot;</span>
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;fasting&quot;</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">feedTheFish</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> day = randomDay()
    <span class="hljs-keyword">val</span> food = fishFood(day)
    println(<span class="hljs-string">&quot;Today is <span class="hljs-variable">$day</span> and the fish eat <span class="hljs-variable">$food</span>&quot;</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">randomDay</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">val</span> week = listOf(
        <span class="hljs-string">&quot;Monday&quot;</span>,
        <span class="hljs-string">&quot;Tuesday&quot;</span>,
        <span class="hljs-string">&quot;Wednesday&quot;</span>,
        <span class="hljs-string">&quot;Thursday&quot;</span>,
        <span class="hljs-string">&quot;Friday&quot;</span>,
        <span class="hljs-string">&quot;Saturday&quot;</span>,
        <span class="hljs-string">&quot;Sunday&quot;</span>
    )
    <span class="hljs-keyword">return</span> week[Random.nextInt(<span class="hljs-number">7</span>)]
}
</div></code></pre>
<h3 id="practice-time-6">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Solution Code</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getBirthday</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> {
    print(<span class="hljs-string">&quot;\nEnter your birthday: &quot;</span>)
    <span class="hljs-keyword">return</span> readLine()?.toIntOrNull() ?: <span class="hljs-number">1</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getFortune</span><span class="hljs-params">(birthday: <span class="hljs-type">Int</span>)</span></span>: String {
    <span class="hljs-keyword">val</span> fortunes = listOf(<span class="hljs-string">&quot;You will have a great day!&quot;</span>,
            <span class="hljs-string">&quot;Things will go well for you today.&quot;</span>,
            <span class="hljs-string">&quot;Enjoy a wonderful day of success.&quot;</span>,
            <span class="hljs-string">&quot;Be humble and all will turn out well.&quot;</span>,
            <span class="hljs-string">&quot;Today is a good day for exercising restraint.&quot;</span>,
            <span class="hljs-string">&quot;Take it easy and enjoy life!&quot;</span>,
            <span class="hljs-string">&quot;Treasure your friends, because they are your greatest fortune.&quot;</span>)n
    <span class="hljs-keyword">val</span> index = <span class="hljs-keyword">when</span> (birthday) {
        <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">7</span> -&gt; <span class="hljs-number">4</span>
        <span class="hljs-number">28</span>, <span class="hljs-number">31</span> -&gt; <span class="hljs-number">2</span>
        <span class="hljs-keyword">else</span> -&gt; birthday.rem(fortunes.size)
    }
    <span class="hljs-keyword">return</span> fortunes[index]
}

<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">import</span> kotlin.random.Random
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span>) {
        <span class="hljs-keyword">val</span> birthday = getBirthday()
        <span class="hljs-keyword">val</span> fortune: Pair&lt;String, <span class="hljs-built_in">Int</span>&gt; = getFortuneCookie(birthday)
        println(<span class="hljs-string">&quot;Your fortune is: <span class="hljs-subst">${fortune.first}</span>&quot;</span>)
        <span class="hljs-keyword">if</span> (fortune.second == <span class="hljs-number">5</span>) {
            <span class="hljs-keyword">break</span>
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getFortuneCookie</span><span class="hljs-params">(birthday: <span class="hljs-type">Int</span>)</span></span>: Pair&lt;String, <span class="hljs-built_in">Int</span>&gt; {
    <span class="hljs-keyword">val</span> fortunes = listOf(
        <span class="hljs-string">&quot;You will have a great day!&quot;</span>,
        <span class="hljs-string">&quot;Things will go well for you today.&quot;</span>,
        <span class="hljs-string">&quot;Enjoy a wonderful day of success.&quot;</span>,
        <span class="hljs-string">&quot;Be humble and all will turn out well.&quot;</span>,
        <span class="hljs-string">&quot;Today is a good day for exercising restraint.&quot;</span>,
        <span class="hljs-string">&quot;Take it easy and enjoy life!&quot;</span>,
        <span class="hljs-string">&quot;Treasure your friends because they are your greatest fortune.&quot;</span>
    )
    <span class="hljs-keyword">val</span> index = <span class="hljs-keyword">when</span> (birthday) {
        <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> -&gt; Random.nextInt(<span class="hljs-number">3</span>)
        <span class="hljs-number">28</span>, <span class="hljs-number">34</span> -&gt; Random.nextInt(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// Means if it is 28 or 34</span>
        <span class="hljs-keyword">else</span> -&gt; birthday.rem(fortunes.size)
    }
    <span class="hljs-keyword">return</span> Pair(fortunes[index], index)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getBirthday</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> {
    print(<span class="hljs-string">&quot;Enter your birthday: &quot;</span>)
    <span class="hljs-keyword">return</span> readLine()?.toIntOrNull() ?: <span class="hljs-number">1</span>
}
</div></code></pre>
<h4 id="parameters">Parameters</h4>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Parameters kotlin can have a default value, this means when you call a function, you don&#x27;t have to specify a value every time for those parameters</span>
<span class="hljs-comment">// If the value is  missing, the default value is used</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    swim()
    swim(<span class="hljs-string">&quot;Slow&quot;</span>) <span class="hljs-comment">// Specify the default argument positionally</span>
    swim(speed = <span class="hljs-string">&quot;Slow&quot;</span>) <span class="hljs-comment">// Or Specify the argument by name</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swim</span><span class="hljs-params">(speed: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;fast&quot;</span>)</span></span> {
    println(<span class="hljs-string">&quot;swimming <span class="hljs-variable">$speed</span>&quot;</span>)
}

<span class="hljs-comment">// You can mix default and positional arguments</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    swim(<span class="hljs-number">5</span>)
    swim(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;Slow&quot;</span>)
    swim(<span class="hljs-number">5</span>,speed = <span class="hljs-string">&quot;Slow&quot;</span>)
    swim(time = <span class="hljs-number">5</span>,speed = <span class="hljs-string">&quot;Slow&quot;</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swim</span><span class="hljs-params">(time: <span class="hljs-type">Int</span>, speed: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;fast&quot;</span>)</span></span> {
    println(<span class="hljs-string">&quot;swimming <span class="hljs-variable">$speed</span>&quot;</span>)
}

<span class="hljs-comment">// It is the best practice to put arguments without defaults first</span>
<span class="hljs-comment">// And then the noes with the defaults afterwards</span>
shouldChangeWater(day, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>)
shouldChangeWater(day)
shouldChangeWater(day, dirty = <span class="hljs-number">50</span>)

<span class="hljs-comment">// Wrong example</span>
shouldChangeWaterWRONG(<span class="hljs-string">&quot;Monday&quot;</span>) <span class="hljs-comment">// Error!</span>
<span class="hljs-comment">// We have to specify that Monday is the day</span>
shouldChangeWaterWRONG(day = <span class="hljs-string">&quot;Monday&quot;</span>)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldChangeWater</span><span class="hljs-params">(day: <span class="hljs-type">String</span>, temperature: <span class="hljs-type">Int</span> = <span class="hljs-number">22</span>, dirty: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span>)</span></span> {
}

<span class="hljs-comment">// You can define a function where the default variables are listed first or</span>
<span class="hljs-comment">// mixed in others, but this easily leads to mistakes</span>
<span class="hljs-comment">// If you forget to list all arguments by name</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldChangeWaterWRONG</span><span class="hljs-params">(temperature: <span class="hljs-type">Int</span> = <span class="hljs-number">22</span>, dirty: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span>, day: <span class="hljs-type">String</span>)</span></span> {
}
</div></code></pre>
<h3 id="practice-time--fit-more-fish">Practice Time | Fit More Fish</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Create a function that checks if we can add another fish into a tank that already has fish in it.

How many fish in a tank?
The most widely known rule for stocking a tank is the one-inch-per-fish-per-gallon-of-water rule. However that&#x27;s assuming the tank doesn&#x27;t have any decorations in it.

Typically, a tank with decorations can contain a total length of fish (in inches) less than or equal to 80% of the tank size (in gallons). A tank without decorations can contain a total length of fish up to 100% of the tank size.

For example:
A 10 gallon tank with decorations can hold up to 8 inches of fish, for example 4 x 2-inch-long fish.
A 20 gallon tank without decorations can hold up to 20 inches of fish, for example 6 x 1-inch-long fish and 2 x 2-inch-long fish.
fitMoreFish function
Create a function that takes these arguments:

tankSize (in gallons)
currentFish (a list of Ints representing the length of each fish currently in the tank)
fishSize (the length of the new fish we want to add to the tank)
hasDecorations (true if the the tank has decorations, false if not)
You can assume that typically a tank has decorations, and that a typical fish is 2 inches long. That means you can set those values as default parameters.

Output
Make sure you test your code against the following calls, and that you get the correct output for each.

canAddFish(10.0, listOf(3,3,3)) ---&gt; false
canAddFish(8.0, listOf(2,2,2), hasDecorations = false) ---&gt; true
canAddFish(9.0, listOf(1,1,3), 3) ---&gt; false
canAddFish(10.0, listOf(), 7, true) ---&gt; true

Things to think about
Again, there are so many ways you can do this, this is one of them:

fun canAddFish(tankSize: Double, currentFish: List&lt;Int&gt;, fishSize: Int = 2, hasDecorations: Boolean = true): Boolean {
return (tankSize * if (hasDecorations) 0.8 else 1.0) &gt;= (currentFish.sum() + fishSize)
}

Notice how you can use the .sum() function in the list? This is a way to add up all elements in a list without having to use loops.*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    println(canAddFish(<span class="hljs-number">10</span>, listOf(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))) <span class="hljs-comment">// ---&gt; false</span>
    println(canAddFish(<span class="hljs-number">8</span>, listOf(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), hasDecorations = <span class="hljs-literal">false</span>)) <span class="hljs-comment">// ---&gt; true</span>
    println(canAddFish(<span class="hljs-number">9</span>, listOf(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>), <span class="hljs-number">3</span>)) <span class="hljs-comment">// ---&gt; false</span>
    println(canAddFish(<span class="hljs-number">10</span>, listOf(), <span class="hljs-number">7</span>, <span class="hljs-literal">true</span>)) <span class="hljs-comment">// ---&gt; true</span>
}

<span class="hljs-comment">// Alternative Shorter Solution</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">canAddFishAlternative</span><span class="hljs-params">(tankSize: <span class="hljs-type">Double</span>, currentFish: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt;, fishSize: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span>, hasDecorations: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> (tankSize * <span class="hljs-keyword">if</span> (hasDecorations) <span class="hljs-number">0.8</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span>) &gt;= (currentFish.sum() + fishSize)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">canAddFish</span><span class="hljs-params">(tankSize: <span class="hljs-type">Int</span>, currentFish: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt;, fishSize: <span class="hljs-type">Int</span> = <span class="hljs-number">2</span>, hasDecorations: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">var</span> availableTankSize = tankSize
    <span class="hljs-comment">// Without decorations, Total length of fish &lt;= 100% of the tank size</span>
    <span class="hljs-keyword">if</span> (!hasDecorations) {
    	availableTankSize -= currentFish.sum()
    }
    <span class="hljs-comment">// With decorations, Total length of fish &lt;= 80% of the tank size</span>
    <span class="hljs-keyword">else</span> {
    	availableTankSize = availableTankSize.times(<span class="hljs-number">4</span>).div(<span class="hljs-number">5</span>)
    	availableTankSize -= currentFish.sum()
    }
    println(<span class="hljs-string">&quot;tankSize: <span class="hljs-variable">$tankSize</span>, sum: <span class="hljs-subst">${currentFish.sum()}</span>, availableTankSize: <span class="hljs-variable">$availableTankSize</span>&quot;</span>)
    <span class="hljs-keyword">return</span> fishSize &lt;= availableTankSize
}
</div></code></pre>
<h3 id="practice-time-7">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Create a program that suggests an activity based on various parameters.

Start in a new file with a main function.
From main(), create a function, whatShouldIDoToday().
Let the function have three parameters.
mood: a required string parameter
weather: a string parameter that defaults to &quot;sunny&quot;
temperature: an Integer parameter that defaults to 24 (Celsius).
Use a when construct to return some activities based on combinations of conditions. For example:
mood == &quot;happy&quot; &amp;&amp; weather == &quot;Sunny&quot; -&gt; &quot;go for a walk&quot;
else -&gt; &quot;Stay home and read.&quot;
Copy/paste your finished function into REPL, and call it with combinations of arguments. For example:
whatShouldIDoToday(&quot;sad&quot;)
&gt; Stay home and read.
Note: Keep your work as you will do more with this code in the next practice.*/</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    println(whatShouldIDoToday(<span class="hljs-string">&quot;happy&quot;</span>))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">whatShouldIDoToday</span><span class="hljs-params">(mood: <span class="hljs-type">String</span>, weather: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;sunny&quot;</span>, temperature: <span class="hljs-type">Int</span> = <span class="hljs-number">24</span>)</span></span> : String {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
      mood == <span class="hljs-string">&quot;happy&quot;</span> &amp;&amp; weather == <span class="hljs-string">&quot;Sunny&quot;</span> -&gt; <span class="hljs-string">&quot;go for a walk&quot;</span>
      <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;Stay home and read.&quot;</span>
    }
}

<span class="hljs-comment">// My Code</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    println(whatShouldIDoToday(<span class="hljs-string">&quot;sad&quot;</span>))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">whatShouldIDoToday</span><span class="hljs-params">(mood: <span class="hljs-type">String</span>, weather: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;sunny&quot;</span>, temperature: <span class="hljs-type">Int</span> = <span class="hljs-number">24</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
    	mood == <span class="hljs-string">&quot;happy&quot;</span> &amp;&amp; weather == <span class="hljs-string">&quot;Sunny&quot;</span> -&gt; <span class="hljs-string">&quot;go for a walk&quot;</span>
    	<span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;Stay home and read.&quot;</span>
    }
}
</div></code></pre>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Return type can be inferred from the function</span>
<span class="hljs-comment">// The name of the function give a hint to the reader about the expected value</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isTooHot</span><span class="hljs-params">(temperature: <span class="hljs-type">Int</span>)</span></span> = temperature &gt; <span class="hljs-number">30</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isDirty</span><span class="hljs-params">(dirty: <span class="hljs-type">Int</span>)</span></span> = dirty &gt; <span class="hljs-number">30</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isSunday</span><span class="hljs-params">(day: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = day == <span class="hljs-string">&quot;Sunday&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldChangeWater</span><span class="hljs-params">(day: <span class="hljs-type">String</span>, temperature: <span class="hljs-type">Int</span> = <span class="hljs-number">22</span>, dirty: <span class="hljs-type">Int</span> = <span class="hljs-number">20</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
<span class="hljs-comment">// Way 3 with one line function syntax</span>
<span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
	isTooHot(temperature) -&gt; <span class="hljs-literal">true</span>
	isDirty(dirty) -&gt; <span class="hljs-literal">true</span>
	isSunday(day) -&gt; <span class="hljs-literal">true</span>
	<span class="hljs-keyword">else</span> -&gt; <span class="hljs-literal">false</span>
}
<span class="hljs-comment">// Way 2</span>
<span class="hljs-comment">//	val isTooHot = temperature &gt; 30</span>
<span class="hljs-comment">//	val isDirty = dirty &gt; 30</span>
<span class="hljs-comment">//	val isSunday = day == &quot;Sunday&quot;</span>
<span class="hljs-comment">//	return when {</span>
<span class="hljs-comment">//		isTooHot -&gt; true</span>
<span class="hljs-comment">//		isDirty -&gt; true</span>
<span class="hljs-comment">//		isSunday -&gt; true</span>
<span class="hljs-comment">//		else -&gt; false</span>
<span class="hljs-comment">//	}</span>

<span class="hljs-comment">// Way 1</span>
<span class="hljs-comment">//	return when {</span>
<span class="hljs-comment">//		temperature &gt; 30 -&gt; true</span>
<span class="hljs-comment">//		dirty &gt; 30 -&gt; true</span>
<span class="hljs-comment">//		day == &quot;Sunday&quot; -&gt; true</span>
<span class="hljs-comment">//		else -&gt; false</span>
<span class="hljs-comment">//	}</span>

<span class="hljs-comment">// Sometimes you might be tempted to use expensive functions to initialize default parameter</span>
<span class="hljs-comment">// Examples of expensive operations include reading files or allocating a lot of memory</span>
<span class="hljs-comment">// BE CAREFUL WITH THIS, They can affect the performance of your code quite a bit</span>
<span class="hljs-comment">// Because Default parameters are evaluated at call time by Kotlin</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDirtySensorReading</span><span class="hljs-params">()</span></span> = <span class="hljs-number">20</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldChangeWater</span><span class="hljs-params">(dirty: <span class="hljs-type">Int</span> = getDirtySensorReading()</span></span>): <span class="hljs-built_in">Boolean</span> {
<span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">///////////////////////////////////////////////////////////////////</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    aquariumStatusReport()
    aquariumStatusReport(<span class="hljs-string">&quot;sfg&quot;</span>)
}
<span class="hljs-comment">/*
* Every time you call aquariumStatusReport() without passing a value for the aquarium argument
* a new aquarium will be made which is costly
* */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeNewAquarium</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;Building a new aquarium.....&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">aquariumStatusReport</span><span class="hljs-params">(aquarium: <span class="hljs-type">Any</span> = makeNewAquarium()</span></span>) {
    <span class="hljs-comment">// Any can hold any type of object</span>
}
<span class="hljs-comment">///////////////////////////////////////////////////////////////////</span>

<span class="hljs-comment">// In kotlin, for and while loops are not expressions</span>
<span class="hljs-keyword">val</span> noValue = <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">2</span>) {} <span class="hljs-comment">// For is not an expression, and only expressions are allowed here!</span>
<span class="hljs-keyword">val</span> notThisEither = <span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>) {} <span class="hljs-comment">// For is not an expression, and only expressions are allowed here!</span>
</div></code></pre>
<h3 id="practice-time-8">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    println(whatShouldIDoToday(<span class="hljs-string">&quot;happy&quot;</span>, <span class="hljs-string">&quot;sunny&quot;</span>))
    println(whatShouldIDoToday(<span class="hljs-string">&quot;sad&quot;</span>))
    print(<span class="hljs-string">&quot;How do you feel?&quot;</span>)
    println(whatShouldIDoToday(readLine()!!))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isVeryHot</span> <span class="hljs-params">(temperature: <span class="hljs-type">Int</span>)</span></span> = temperature &gt; <span class="hljs-number">35</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isSadRainyCold</span> <span class="hljs-params">(mood: <span class="hljs-type">String</span>, weather: <span class="hljs-type">String</span>, temperature: <span class="hljs-type">Int</span>)</span></span> =
mood == <span class="hljs-string">&quot;sad&quot;</span> &amp;&amp; weather == <span class="hljs-string">&quot;rainy&quot;</span> &amp;&amp; temperature == <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isHappySunny</span> <span class="hljs-params">(mood: <span class="hljs-type">String</span>, weather: <span class="hljs-type">String</span>)</span></span> = mood == <span class="hljs-string">&quot;happy&quot;</span> &amp;&amp; weather == <span class="hljs-string">&quot;sunny&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">whatShouldIDoToday</span><span class="hljs-params">(mood: <span class="hljs-type">String</span>, weather: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;sunny&quot;</span>, temperature: <span class="hljs-type">Int</span> = <span class="hljs-number">24</span>)</span></span> : String {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
        isVeryHot(temperature) -&gt; <span class="hljs-string">&quot;go swimming&quot;</span>
        isSadRainyCold(mood, weather, temperature) -&gt; <span class="hljs-string">&quot;stay in bed&quot;</span>
        isHappySunny(mood, weather) -&gt; <span class="hljs-string">&quot;go for a walk&quot;</span>
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;Stay home and read.&quot;</span>
    }
}

<span class="hljs-comment">// My Code</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    print(<span class="hljs-string">&quot;Enter mood: &quot;</span>)
    <span class="hljs-keyword">val</span> mood = readLine().orEmpty() <span class="hljs-comment">// OR -&gt;   readLine() ?: &quot;&quot;</span>
    <span class="hljs-comment">// Double Bang operator does the following line;</span>
    <span class="hljs-comment">// if (readLine() != null) readLine() else throw 	NullPointerException(&quot;Expression &#x27;readLine()&#x27; must not be null&quot;)</span>
    println(whatShouldIDoToday(mood))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldWalk</span><span class="hljs-params">(mood: <span class="hljs-type">String</span>, weather: <span class="hljs-type">String</span>)</span></span> = mood == <span class="hljs-string">&quot;happy&quot;</span> &amp;&amp; weather == <span class="hljs-string">&quot;sunny&quot;</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldSleep</span><span class="hljs-params">(mood: <span class="hljs-type">String</span>, weather: <span class="hljs-type">String</span>, temperature: <span class="hljs-type">Int</span>)</span></span> = mood == <span class="hljs-string">&quot;sad&quot;</span> &amp;&amp; weather == <span class="hljs-string">&quot;rainy&quot;</span> &amp;&amp; temperature == <span class="hljs-number">0</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldSwim</span><span class="hljs-params">(mood: <span class="hljs-type">String</span>, weather: <span class="hljs-type">String</span>, temperature: <span class="hljs-type">Int</span>)</span></span> = temperature &gt; <span class="hljs-number">35</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">whatShouldIDoToday</span><span class="hljs-params">(mood: <span class="hljs-type">String</span>, weather: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;sunny&quot;</span>, temperature: <span class="hljs-type">Int</span> = <span class="hljs-number">24</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
        shouldWalk(mood, weather) -&gt; <span class="hljs-string">&quot;go for a walk&quot;</span>
        shouldSleep(mood, weather, temperature) -&gt; <span class="hljs-string">&quot;stay in bed&quot;</span>
        shouldSwim(mood, weather, temperature) -&gt; <span class="hljs-string">&quot;go swimming&quot;</span>
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;Stay home and read.&quot;</span>
    }
}
</div></code></pre>
<h3 id="repeat-and-while">Repeat and While</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Using repeat:</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    <span class="hljs-keyword">var</span> fortune: String = <span class="hljs-string">&quot;&quot;</span>
    repeat (<span class="hljs-number">10</span>) {
        fortune = getFortune(getBirthday())
        println(<span class="hljs-string">&quot;\nYour fortune is: <span class="hljs-variable">$fortune</span>&quot;</span>)
        <span class="hljs-keyword">if</span> (fortune.contains(<span class="hljs-string">&quot;Take it easy&quot;</span>)) <span class="hljs-keyword">break</span>;
    }
}

<span class="hljs-comment">// Using a while loop:</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    <span class="hljs-keyword">var</span> fortune: String = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-keyword">while</span> (!fortune.contains(<span class="hljs-string">&quot;Take it easy&quot;</span>)) {
        fortune = getFortune(getBirthday())
        println(<span class="hljs-string">&quot;\nYour fortune is: <span class="hljs-variable">$fortune</span>&quot;</span>)
    }
}
</div></code></pre>
<h3 id="filters">Filters</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;ghf&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;tur&quot;</span>)
println(list.filter { it[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;a&#x27;</span> }) <span class="hljs-comment">// Outputs: [abc, aaa]</span>
<span class="hljs-comment">// Returns the elements that satisfy the condition it[0] == &#x27;a&#x27;</span>
<span class="hljs-comment">// In Kotlin, &#x27;c&#x27; -&gt; characters, &quot;string&quot; -&gt; string</span>
<span class="hljs-comment">// Strings and chars are not interchangebla// They are different things!</span>
<span class="hljs-comment">// For example  list.filter { it[0] == &quot;a&quot; }  // ERROR// because we do char == string which is not valid</span>

<span class="hljs-comment">// Filter is a standard library function on list in kotlin</span>

<span class="hljs-comment">// The difference between EAGER and LAZY</span>
<span class="hljs-comment">// -&gt; AN EAGER algorithm executes immediately and returns a result.</span>
<span class="hljs-comment">// -&gt; A LAZY algorithm defers computation until it is necessary to execute and then produces a result.</span>

<span class="hljs-comment">// By default, filter analyst is EAGER that means everytime you call filter, it creates a new list with he elements that pass through the filter</span>

<span class="hljs-comment">// EAGER example</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;rock&quot;</span>, <span class="hljs-string">&quot;pagoda&quot;</span>, <span class="hljs-string">&quot;plastic&quot;</span>, <span class="hljs-string">&quot;tur&quot;</span>)
    <span class="hljs-comment">// Decoration EAGER here// We&#x27;ll hold a new list</span>
    <span class="hljs-comment">// containing strings that starts with &#x27;p&#x27;</span>
    <span class="hljs-keyword">val</span> decorations = list.filter { it[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;p&#x27;</span> }
    println(decorations)
}

<span class="hljs-comment">// If you want LAZY Behaviour, you can use SEQUENCES// A sequence is a collection that only look at one item at a time starting at the beginning and going to the end, conveniently, this is exactly the API filter needs</span>

<span class="hljs-comment">// When you return the filter results as a sequence, our filtered variable won&#x27;t hold a new list, it will hold a sequence of all of the list elements and knowledge of the filter to apply to its elements</span>

<span class="hljs-comment">// Ehenever you access elements of the sequence, the filter is applied and the results are returned to you</span>

<span class="hljs-comment">// Of course, if we want to turn our sequence back into the list, we can call &quot;toList()&quot; at that point, a filter will be run and all of the values that start with P will be put in the new list</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;rock&quot;</span>, <span class="hljs-string">&quot;pagoda&quot;</span>, <span class="hljs-string">&quot;plastic&quot;</span>, <span class="hljs-string">&quot;tur&quot;</span>)
    <span class="hljs-comment">// Apply filter LAZILY</span>
    <span class="hljs-keyword">val</span> decorations = list.asSequence().filter { it[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;p&#x27;</span> }
    println(decorations) <span class="hljs-comment">// kotlin.sequences.FilteringSequence@1fb3ebeb</span>
    println(decorations.toList()) <span class="hljs-comment">// Ignite the filter!: [pagoda, plastic]</span>
}

<span class="hljs-comment">// Let&#x27;s use the function map and tell it to print every item, since it&#x27;s lazy, calling map does not print anything</span>

<span class="hljs-comment">// Let&#x27;s use the function map and tell it to print every item</span>
<span class="hljs-keyword">val</span> lazyMap = decorations.asSequence().map {
    println(<span class="hljs-string">&quot;map <span class="hljs-variable">$it</span>&quot;</span>)
    it
}
println(lazyMap) <span class="hljs-comment">// kotlin.sequences.TransformingSequence@53d8d10a</span>

<span class="hljs-comment">// When I take the first element however, you can see that the map operation reads the first value</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;rock&quot;</span>, <span class="hljs-string">&quot;pagoda&quot;</span>, <span class="hljs-string">&quot;plastic&quot;</span>, <span class="hljs-string">&quot;tur&quot;</span>)
    <span class="hljs-comment">// Apply filter LAZILY</span>
    <span class="hljs-keyword">val</span> decorations = list.asSequence().filter { it[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;p&#x27;</span> }
    <span class="hljs-comment">// Let&#x27;s use the function map and tell it to print every item</span>
    <span class="hljs-keyword">val</span> lazyMap = decorations.asSequence().map {
        println(<span class="hljs-string">&quot;map <span class="hljs-variable">$it</span>&quot;</span>) <span class="hljs-comment">// map pagoda</span>
        it
    }
    println(lazyMap) <span class="hljs-comment">// kotlin.sequences.TransformingSequence@53d8d10a</span>
    println(<span class="hljs-string">&quot;first: <span class="hljs-subst">${lazyMap.first()}</span>&quot;</span>) <span class="hljs-comment">// first: pagoda</span>
}

<span class="hljs-comment">// Of course taking the full list will iterate over all the values</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;rock&quot;</span>, <span class="hljs-string">&quot;pagoda&quot;</span>, <span class="hljs-string">&quot;plastic&quot;</span>, <span class="hljs-string">&quot;tur&quot;</span>)
    <span class="hljs-comment">// Apply filter LAZILY</span>
    <span class="hljs-keyword">val</span> decorations = list.asSequence().filter { it[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;p&#x27;</span> }
    <span class="hljs-comment">// Let&#x27;s use the function map and tell it to print every item</span>
    <span class="hljs-keyword">val</span> lazyMap = decorations.asSequence().map {
        println(<span class="hljs-string">&quot;map <span class="hljs-variable">$it</span>&quot;</span>)
        it
    }
    println(<span class="hljs-string">&quot;all: <span class="hljs-subst">${lazyMap.toList()}</span>&quot;</span>)
}

<span class="hljs-comment">// map pagoda</span>
<span class="hljs-comment">// map plastic</span>
<span class="hljs-comment">// all: [pagoda, plastic]</span>
</div></code></pre>
<h3 id="practice-time-9">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*You can do the following filter exercise in REPL.

Create a list of spices, as follows:
val spices = listOf(&quot;curry&quot;, &quot;pepper&quot;, &quot;cayenne&quot;, &quot;ginger&quot;, &quot;red curry&quot;, &quot;green curry&quot;, &quot;red pepper&quot; )

Create a filter that gets all the curries and sorts them by string length.
Hint: After you type the dot (.), IntelliJ will give you a list of functions you can apply.

Filter the list of spices to return all the spices that start with &#x27;c&#x27; and end in &#x27;e&#x27;. Do it in two different ways.

Take the first three elements of the list and return the ones that start with &#x27;c&#x27;.

Note: We will be able to do a lot more interesting stuff with filters after you learn about classes and Map.*/</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> spices = listOf(<span class="hljs-string">&quot;curry&quot;</span>, <span class="hljs-string">&quot;pepper&quot;</span>, <span class="hljs-string">&quot;cayenne&quot;</span>, <span class="hljs-string">&quot;ginger&quot;</span>, <span class="hljs-string">&quot;red curry&quot;</span>, <span class="hljs-string">&quot;green curry&quot;</span>, <span class="hljs-string">&quot;red pepper&quot;</span>)
    <span class="hljs-comment">// 2</span>
    println(spices.filter { s -&gt; s.contains(<span class="hljs-string">&quot;curry&quot;</span>) }.sortedBy { s -&gt; s.length })
    <span class="hljs-comment">// 3</span>
    println(spices.filter { s -&gt; s.startsWith(<span class="hljs-string">&#x27;c&#x27;</span>) &amp;&amp; s.endsWith(<span class="hljs-string">&#x27;e&#x27;</span>) })
    println(spices.filter { s -&gt; s.first() == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; s.last() == <span class="hljs-string">&#x27;e&#x27;</span> })
    println(spices.filter { s -&gt; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; s[s.length - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;e&#x27;</span> })
    <span class="hljs-comment">// 4</span>
    println(spices.take(<span class="hljs-number">3</span>).filter { s -&gt; s.first() == <span class="hljs-string">&#x27;c&#x27;</span> })

    <span class="hljs-comment">// OR WE CAN USE &quot;it&quot;</span>
    <span class="hljs-keyword">val</span> spices = listOf(<span class="hljs-string">&quot;curry&quot;</span>, <span class="hljs-string">&quot;pepper&quot;</span>, <span class="hljs-string">&quot;cayenne&quot;</span>, <span class="hljs-string">&quot;ginger&quot;</span>, <span class="hljs-string">&quot;red curry&quot;</span>, <span class="hljs-string">&quot;green curry&quot;</span>, <span class="hljs-string">&quot;red pepper&quot;</span>)
    <span class="hljs-comment">// 2</span>
    println(spices.filter { it.contains(<span class="hljs-string">&quot;curry&quot;</span>) }.sortedBy { it.length })
    <span class="hljs-comment">// 3</span>
    println(spices.filter { it.startsWith(<span class="hljs-string">&#x27;c&#x27;</span>) &amp;&amp; it.endsWith(<span class="hljs-string">&#x27;e&#x27;</span>) })
    println(spices.filter { it.first() == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; it.last() == <span class="hljs-string">&#x27;e&#x27;</span> })
    println(spices.filter { it[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; it[it.length - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;e&#x27;</span> })
    <span class="hljs-comment">// 4</span>
    println(spices.take(<span class="hljs-number">3</span>).filter { it.first() == <span class="hljs-string">&#x27;c&#x27;</span> })
}

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-comment">// Sorting curries by string length</span>
spices.filter { it.contains(<span class="hljs-string">&quot;curry&quot;</span>) }.sortedBy { it.length }

<span class="hljs-comment">// Filtering by those that start with &#x27;c&#x27; and end with &#x27;e&#x27;</span>
spices.filter{it.startsWith(<span class="hljs-string">&#x27;c&#x27;</span>)}.filter{it.endsWith(<span class="hljs-string">&#x27;e&#x27;</span>)}
&gt; [cayenne]
<span class="hljs-comment">// OR</span>
spices.filter { {it.startsWith(<span class="hljs-string">&#x27;c&#x27;</span>) &amp;&amp; it.endsWith(<span class="hljs-string">&#x27;e&#x27;</span>) }
&gt; [cayenne]

<span class="hljs-comment">// Filtering the first 3 items by &#x27;c&#x27;</span>
spices.take(<span class="hljs-number">3</span>).filter{it.startsWith(<span class="hljs-string">&#x27;c&#x27;</span>)}
&gt; [curry, cayenne]
</div></code></pre>
<h3 id="kotlin-labmdas">Kotlin Labmdas</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Lambda functions are used when you need a function FOR A SHORT PERIOD OF TIME.</span>
<span class="hljs-comment">// A LAMBDA is an expression that makes a function, instead of declaring a named function, we declare a function that has no name</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Lambda function</span>
    { println(<span class="hljs-string">&quot;Hello&quot;</span>) }()
}

<span class="hljs-comment">// We can declera a variable called swim and assign it to a lambda</span>
<span class="hljs-comment">// Lambda function, If we put &quot;()&quot; this runs/calls the lambda function</span>
{ println(<span class="hljs-string">&quot;Hello&quot;</span>) }() <span class="hljs-comment">// Hello</span>

<span class="hljs-comment">// We can also say:   run { println(&quot;Hello&quot;) } // Hello</span>
<span class="hljs-comment">// We can declera a variable called swim and assign it to a lambda</span>
<span class="hljs-keyword">var</span> swimDontRun = { println(<span class="hljs-string">&quot;swim&quot;</span>) } <span class="hljs-comment">// swim</span>
<span class="hljs-keyword">var</span> swimRunDirectly = { println(<span class="hljs-string">&quot;swim&quot;</span>) }() <span class="hljs-comment">// swim</span>
<span class="hljs-keyword">var</span> swimRunDirectly2 = run { println(<span class="hljs-string">&quot;swim&quot;</span>) } <span class="hljs-comment">// swim</span>

<span class="hljs-comment">// We can call variable just like a regular function</span>
swimDontRun() <span class="hljs-comment">// Output: swim</span>

<span class="hljs-comment">// Lambdas can take arguments just like named functions</span>
<span class="hljs-comment">// Lambda arguments go on the left hand side of what&#x27;s called a function arrow</span>
<span class="hljs-comment">// The body of the lambda goes after the function arrow</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">var</span> dirty = <span class="hljs-number">20</span>
    <span class="hljs-keyword">val</span> waterFilter = { dirty: <span class="hljs-built_in">Int</span> -&gt; dirty / <span class="hljs-number">2</span> }
    println(waterFilter(dirty)) <span class="hljs-comment">// 10</span>
    <span class="hljs-comment">// waterFilter can be any function that takes an int and returns an int</span>
    <span class="hljs-keyword">val</span> waterFilter2: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = { abc: <span class="hljs-built_in">Int</span> -&gt; abc + <span class="hljs-number">2</span> }
    <span class="hljs-comment">// We don&#x27;t have to specify the type of the lambda argument anymore</span>
    <span class="hljs-keyword">val</span> waterFilter3: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = { abc -&gt; abc + <span class="hljs-number">2</span> }
}
</div></code></pre>
<h3 id="higher-order-functions">Higher-Order Functions</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// The real power of lambda happens when we make higher-order functions</span>
<span class="hljs-comment">// A higher-order function is just any function that takes a function as the argument</span>
<span class="hljs-comment">// Kotlin prefers function arguments to be the last parameter</span>
<span class="hljs-comment">// Higher-order function that takes function as an argument</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDirty</span><span class="hljs-params">(dirty: <span class="hljs-type">Int</span>, operation: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> operation(dirty)
}

<span class="hljs-comment">/*
* When you combine higher-order functions with lambdas
* Kotlin has a special syntax
* it&#x27;s called the last parameter called syntax
* */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dirtyProcessor</span><span class="hljs-params">()</span></span> {
    dirty = updateDirty(dirty, waterFilter)
    println(<span class="hljs-string">&quot;1: <span class="hljs-variable">$dirty</span>&quot;</span>)
    <span class="hljs-comment">// since feedFish is a named function and not a lambda</span>
    <span class="hljs-comment">// you&#x27;ll need to use a double colon to pass it</span>
    <span class="hljs-comment">// This way Kotlin know you&#x27;re not trying to call feedFish</span>
    <span class="hljs-comment">// and it will let you pass a REFERENCE</span>
    <span class="hljs-comment">// So here we don&#x27;t call the function but we pass it to another function and then</span>
    <span class="hljs-comment">// that function will run the function passed it to</span>
    dirty = updateDirty(dirty, ::feedFish)
    <span class="hljs-comment">// &quot; :: &quot; means, it creates a member reference or a class reference.</span>
    println(<span class="hljs-string">&quot;2: <span class="hljs-variable">$dirty</span>&quot;</span>)
    <span class="hljs-comment">// Above method is similar as the following</span>
    dirty = feedFish(dirty)
    println(<span class="hljs-string">&quot;22: <span class="hljs-variable">$dirty</span>&quot;</span>)
    <span class="hljs-comment">// Here we call updateDirty again, but this time</span>
    <span class="hljs-comment">// we pass a lambda as an argument for the parameter operation</span>
    <span class="hljs-comment">/*
    * What&#x27;s really interesting here, a lambda is an argument to updateDirty
    * but since we&#x27;re passing it as the last parameter
    * we don&#x27;t have to put it inside the function parentheses
    * */</span>
    dirty = updateDirty(dirty) { dirty -&gt;
    	dirty + <span class="hljs-number">50</span>
    }
    <span class="hljs-comment">/*
    * To really show you what is going on,
    * you can put the parentheses back in, here you can see we&#x27;re just
    * passing the lambda as an argument updateDirty
    * */</span>
    dirty = updateDirty(dirty, { dirty -&gt;
    	dirty + <span class="hljs-number">50</span>
    })
    <span class="hljs-comment">/*
    * Using this syntax we can define functions that look like they&#x27;re built-in to the language
    * Actually, we&#x27;ve already used a few higher-order functions from the standard library
    * */</span>
    <span class="hljs-keyword">val</span> list = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    list.filter {
    	it == <span class="hljs-number">2</span>
    }
    <span class="hljs-comment">/*
    * The filter function we used in the last section, takes a lambda and
    * uses it to filter a list,
    * repeat is also just a function that takes a repeat count and a lambda that is repeated
    * */</span>
}
</div></code></pre>
<h3 id="practice-time-10">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// What is the difference between?</span>
<span class="hljs-keyword">val</span> random1 = random()
<span class="hljs-keyword">val</span> random2 = { random() }
<span class="hljs-comment">// Try it out in REPL or a file:</span>
&gt; The second will generate a random number every time random2 <span class="hljs-keyword">is</span> accessed.
<span class="hljs-comment">// ANSWER</span>
<span class="hljs-comment">// random1 has a value assigned at compile time, and the value never changes when the variable is accessed.</span>
<span class="hljs-comment">// random2 has a lambda assigned at compile time, and the lambda is executed every time the variable is referenced, returning a different value.</span>
</div></code></pre>
<h3 id="practice-time--lambdas">Practice Time | Lambdas</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Create a lambda and assign it to rollDice, which returns a dice roll (number between 1 and 12).</span>
<span class="hljs-comment">// Extend the lambda to take an argument indicating the number of sides of the dice used for the roll.</span>
<span class="hljs-comment">// If you haven&#x27;t done so, fix the lambda to return 0 if the number of sides passed in is 0.</span>
<span class="hljs-comment">// Create a new variable, rollDice2, for this same lambda using the function type notation.</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-keyword">val</span> rollDice = { Random().nextInt(<span class="hljs-number">12</span>) + <span class="hljs-number">1</span>}
<span class="hljs-keyword">val</span> rollDice = { sides: <span class="hljs-built_in">Int</span> -&gt;
    Random().nextInt(sides) + <span class="hljs-number">1</span>
}
<span class="hljs-keyword">val</span> rollDice0 = { sides: <span class="hljs-built_in">Int</span> -&gt;
    <span class="hljs-keyword">if</span> (sides == <span class="hljs-number">0</span>) <span class="hljs-number">0</span>
    <span class="hljs-keyword">else</span> Random().nextInt(sides) + <span class="hljs-number">1</span>
}
<span class="hljs-keyword">val</span> rollDice2: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = { sides -&gt;
    <span class="hljs-keyword">if</span> (sides == <span class="hljs-number">0</span>) <span class="hljs-number">0</span>
    <span class="hljs-keyword">else</span> Random().nextInt(sides) + <span class="hljs-number">1</span>
}

<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">import</span> kotlin.random.Random
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> rollDice6Sides = { Random.nextInt(<span class="hljs-number">12</span>) + <span class="hljs-number">1</span> }
    <span class="hljs-keyword">val</span> rollDice = { sides: <span class="hljs-built_in">Int</span> -&gt;
    	<span class="hljs-keyword">if</span> (sides == <span class="hljs-number">0</span>) <span class="hljs-number">0</span>
    	<span class="hljs-keyword">else</span> Random.nextInt(sides) + <span class="hljs-number">1</span>
    }
    repeat(<span class="hljs-number">10</span>) {
    	println(<span class="hljs-string">&quot;<span class="hljs-subst">${rollDice(<span class="hljs-number">0</span>)}</span>&quot;</span>)
    }
    <span class="hljs-keyword">val</span> rollDice2: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = { sides: <span class="hljs-built_in">Int</span> -&gt;
    	<span class="hljs-keyword">if</span> (sides == <span class="hljs-number">0</span>) <span class="hljs-number">0</span>
    	<span class="hljs-keyword">else</span> Random.nextInt(sides) + <span class="hljs-number">1</span>
    }
}
</div></code></pre>
<h3 id="practice-time--extra-questions">Practice Time | Extra Questions</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Why would you want to use the function type notation instead of just the lambda?</span>

<span class="hljs-comment">// Create a function gamePlay() that takes a roll of the dice as an argument and prints it out.</span>

<span class="hljs-comment">// Pass your rollDice2 function as an argument to gamePlay() to generate a dice roll every time gamePlay() is called.</span>

<span class="hljs-comment">// Solution Explanation</span>
<span class="hljs-comment">// Function type notation is MORE READABLE, which REDUCES ERRORS, clearly showing the what type is passed in and what type is returned.</span>

<span class="hljs-comment">// Solution Code</span>
gamePlay(rollDice2(<span class="hljs-number">4</span>))
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">gamePlay</span><span class="hljs-params">(diceRoll: <span class="hljs-type">Int</span>)</span></span>{
    <span class="hljs-comment">// do something with the dice roll</span>
    println(diceRoll)
}

<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">import</span> kotlin.random.Random
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Why would you want to use the function type notation instead of just the lambda?</span>
    <span class="hljs-comment">// -&gt; We might want to know what type we pass in the function</span>
    <span class="hljs-comment">// this will reduce errors related to parameters</span>
    <span class="hljs-keyword">val</span> dice = { sides: <span class="hljs-built_in">Int</span> -&gt;
    	Random.nextInt(sides) + <span class="hljs-number">1</span>
    }
    <span class="hljs-keyword">val</span> rollDice2: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = { sides: <span class="hljs-built_in">Int</span> -&gt;
    	<span class="hljs-keyword">if</span> (sides == <span class="hljs-number">0</span>) <span class="hljs-number">0</span>
    	<span class="hljs-keyword">else</span> Random.nextInt(sides) + <span class="hljs-number">1</span>
    }
    gamePlay(dice, rollDice2)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">gamePlay</span><span class="hljs-params">(dice: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>, dice2: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span> {
    println(dice2(<span class="hljs-number">6</span>))
    println(dice(<span class="hljs-number">6</span>))
}
</div></code></pre>
<h2 id="l4">Lesson 4 | Classes</h2>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
Classes are blue prints for objects

-&gt; Class - Object Blueprint
(like an Aquarium Plan)

-&gt; Objects are instances of classes that is the actual aquarium
(Actual Aquarium)

-&gt; Properties are characteristics of classes such as the length
(Aquarium width, height)

-&gt; Methods are the functionality of the class, class function, what the object could do, for example fill with water
( fillWithWater() )

-&gt; Interfaces are a specification that a class can implement
(Specification a class can implement ( Clean )), for example, cleaning is common not just to aquariums and cleaning generally happens in similar ways, So we can have an interface clean and aquarium could implement it
*/</span>
</div></code></pre>
<h3 id="practice-time-11">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Earlier, we created and filtered a list of spices. Spices are much better represented as objects than as simple strings. Because they are objects, we can perform different things with them - such as cooking.

To recap, let&#x27;s make a simple Spice class. It doesn&#x27;t do much, but it will serve as the starting point for the next practice.

Create class, SimpleSpice.
Let the class be a property with a String for the name of the spice, and a String for the level of spiciness.
Set the name to curry and the spiciness to mild.
Using a string for spiciness is nice for users, but not useful for calculations. Add a heat property to your class with a getter that returns a numeric value for spiciness. Use a value of 5 for mild.
Create an instance of SimpleSpice and print out its name and heat.*/</span>

<span class="hljs-comment">// My Code</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spice</span> </span>{
    <span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;curry&quot;</span>
    <span class="hljs-keyword">var</span> spiciness: String = <span class="hljs-string">&quot;mild&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">heat</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> {
    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (spiciness) {
    		<span class="hljs-string">&quot;mild&quot;</span> -&gt; <span class="hljs-number">5</span>
    		<span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">6</span>
    	}
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Create spice class instance</span>
    <span class="hljs-keyword">val</span> mySpice = Spice()
    println(<span class="hljs-string">&quot;name: <span class="hljs-subst">${mySpice.name}</span>, heat: <span class="hljs-subst">${mySpice.heat()}</span>&quot;</span>)
}


<span class="hljs-comment">// Solution Code</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleSpice</span></span>() {
    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;curry&quot;</span>
    <span class="hljs-keyword">val</span> spiciness = <span class="hljs-string">&quot;mild&quot;</span>
    <span class="hljs-keyword">val</span> heat: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() {<span class="hljs-keyword">return</span> <span class="hljs-number">5</span> }
}
<span class="hljs-comment">// In main</span>
<span class="hljs-keyword">val</span> simpleSpice = SimpleSpice()
println(<span class="hljs-string">&quot;<span class="hljs-subst">${simpleSpice.name}</span> <span class="hljs-subst">${simpleSpice.heat}</span>&quot;</span>)
</div></code></pre>
<h3 id="package-visibility">Package Visibility</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// In kotlin everything is public by default, that means all of your variables and classes can be accessed everywhere, even the member variables of an object</span>

<span class="hljs-comment">// Visibility modifiers in Kotlin</span>
-&gt; <span class="hljs-keyword">public</span> - Default. Everywhere
-&gt; <span class="hljs-keyword">private</span> - File
-&gt; <span class="hljs-keyword">internal</span> - Module

<span class="hljs-comment">// At the packege level, if you don&#x27;t specify any visibility modifier,</span>
<span class="hljs-comment">// &quot; public &quot; is used by default</span>
<span class="hljs-comment">// Which means that your devlarations will be visible everywhere</span>
<span class="hljs-comment">// A module is a set of Kotlin files compiled together, when it&#x27;s internal we can use it from anywhere inside our project</span>

<span class="hljs-comment">// For members declared inside the class, again by default they are public</span>
</div></code></pre>
<h3 id="class-visibility">Class Visibility</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Public means that any client who sees the class can also see it&#x27;s public members</span>
<span class="hljs-comment">// Private means members are only visible inside the class, importantly subclasses can&#x27;t see private members </span>
<span class="hljs-comment">// Protected means the same as private but members are also visible to subclasses</span>
<span class="hljs-comment">// Class members can have a visibility of internal as well</span>
</div></code></pre>
<h3 id="class-examples">Class Examples</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Sample Code</span>
<span class="hljs-comment">// FILE: Main</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">//  Create spice class instance</span>
    <span class="hljs-comment">//	val mySpice = Spice()</span>
    <span class="hljs-comment">//	println(&quot;name: ${mySpice.name}, heat: ${mySpice.heat}&quot;)</span>
    buildAquarium()
}

<span class="hljs-comment">// If you mark a declaration private,</span>
<span class="hljs-comment">// it will only be visible the inside the file containing declaration</span>
<span class="hljs-comment">// Since we&#x27;re only going to use buildAquarium inside this file</span>
<span class="hljs-comment">// We can make it private</span>
<span class="hljs-comment">// If you mark buildAquarium &quot; internal &quot; it is visible anywhere in the same module</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">buildAquarium</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Creates new instance of Aquarium by calling its constructor</span>
    <span class="hljs-keyword">val</span> myAquarium = Aquarium()
    <span class="hljs-comment">// Under the hood, Kotlin actually made a getter for all three properties</span>
    <span class="hljs-comment">// Even though we did not write any code</span>
    println(<span class="hljs-string">&quot;Length: <span class="hljs-subst">${myAquarium.length}</span>&quot;</span> +
    <span class="hljs-string">&quot; Width: <span class="hljs-subst">${myAquarium.width}</span>&quot;</span> +
    <span class="hljs-string">&quot; Height: <span class="hljs-subst">${myAquarium.height}</span>&quot;</span>)

    <span class="hljs-comment">// We don&#x27;t have to chance &quot; myAquarium &quot; to a var because, we&#x27;re not changing the aquarium</span>
    <span class="hljs-comment">// It&#x27;s the same object we&#x27;re modifying its properties</span>
    myAquarium.height = <span class="hljs-number">80</span>
    println(<span class="hljs-string">&quot;New Height: <span class="hljs-subst">${myAquarium.height}</span> cm&quot;</span>)
    println(<span class="hljs-string">&quot;Volume: <span class="hljs-subst">${myAquarium.volume}</span> liter&quot;</span>)
}

<span class="hljs-comment">// FILE: Aquarium</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aquarium</span> </span>{
    <span class="hljs-keyword">var</span> length = <span class="hljs-number">100</span>
    <span class="hljs-keyword">var</span> width = <span class="hljs-number">20</span>
    <span class="hljs-keyword">var</span> height = <span class="hljs-number">40</span>

    <span class="hljs-comment">// Sample Getter/Setter Syntax</span>
    <span class="hljs-keyword">var</span> volume: <span class="hljs-built_in">Int</span>
    	<span class="hljs-keyword">get</span>() {
    		<span class="hljs-keyword">return</span> width * height * length / <span class="hljs-number">1000</span>
    	}
    	<span class="hljs-keyword">set</span>(value) {
    		height = (value * <span class="hljs-number">1000</span>) / (width * length)
    	}

    <span class="hljs-comment">// Alternative one liner Getter/Setter Syntax</span>
    <span class="hljs-keyword">var</span> volume2: <span class="hljs-built_in">Int</span>
    	<span class="hljs-keyword">get</span>() = width * height * length / <span class="hljs-number">1000</span>
    	<span class="hljs-comment">// By convention, the name of the setter parameter is &quot; value &quot;</span>
    	<span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>(value) { height = (value * <span class="hljs-number">1000</span>) / (width * length) }
    	<span class="hljs-comment">// If we didn&#x27;t want anyone outside the class to be able to use</span>
    	<span class="hljs-comment">// the setter, we could make it private</span>
    	<span class="hljs-comment">// private set(value) { height = (value * 1000) / (width * length) }</span>
    	<span class="hljs-comment">// In kotlin everything is public by default</span>

    <span class="hljs-comment">//	fun volume(): Int {</span>
    <span class="hljs-comment">//		return width * height * length / 1000</span>
    <span class="hljs-comment">//	}</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">//	// Alternative, one liner</span>
    <span class="hljs-comment">//	fun volume1() = width * height * length / 1000</span>
}

<span class="hljs-comment">// Sample Code For Classes</span>
<span class="hljs-keyword">package</span> Aquarium

<span class="hljs-comment">// Constructor</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>(id: <span class="hljs-built_in">Int</span>, name: String, <span class="hljs-keyword">val</span> testVal: String) {
    <span class="hljs-comment">/*
    * The primary constructor cannot contain any code.
    * Initialization code can be placed in initializer blocks,
    * which are prefixed with the init keyword.
    * */</span>
    <span class="hljs-comment">// As the name says,</span>
    <span class="hljs-comment">// &quot;also&quot; expressions does some additional processing on the object it was invoked.</span>
    <span class="hljs-comment">// Unlike let, it returns the original object instead of any new return data.</span>
    <span class="hljs-keyword">var</span> firstProperty = <span class="hljs-string">&quot;First property: <span class="hljs-variable">$name</span>&quot;</span>.also(::println)
    <span class="hljs-comment">// Alternative of &quot; also &quot;</span>
    <span class="hljs-comment">// val b = &quot;SDads: $name&quot;.also { println(it) }</span>

    <span class="hljs-keyword">init</span> {
    	<span class="hljs-comment">// ....</span>
    	println(<span class="hljs-string">&quot;First this block will be executed&quot;</span>)
    }

    <span class="hljs-keyword">val</span> secondProperty = <span class="hljs-string">&quot;Second property: <span class="hljs-subst">${name.length}</span>&quot;</span>.also(::println)
    <span class="hljs-keyword">init</span> {
    	println(<span class="hljs-string">&quot;Second initializer block that prints <span class="hljs-subst">${name.length}</span>&quot;</span>)
    }
}

<span class="hljs-comment">// The class can also declare secondary constructors, which are prefixed with constructor</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> pets: MutableList&lt;Pet&gt; = mutableListOf())

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>{
    <span class="hljs-comment">// Secondary constructor</span>
    <span class="hljs-keyword">constructor</span>(owner: Person) {
    	<span class="hljs-comment">// Add this pet to he list of its owner&#x27;s</span>
    	owner.pets.add(<span class="hljs-keyword">this</span>)
    }
}

<span class="hljs-comment">/*
* A class in Kotlin can have a primary constructor and one or more secondary constructors.
* The primary constructor is part of the class header:
* it goes after the class name (and optional type parameters).
* */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">constructor</span></span>(firstName: String) {

}

<span class="hljs-comment">// If the primary constructor does not have any annotations or visibility modifiers,</span>
<span class="hljs-comment">// the constructor keyword can be omitted:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person2</span> </span>(firstName: String) {

}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> test = Test(<span class="hljs-number">24</span>, <span class="hljs-string">&quot;Melo&quot;</span>)
    println(<span class="hljs-string">&quot;Age: <span class="hljs-subst">${test.firstProperty}</span>, Name: <span class="hljs-subst">${test.secondProperty}</span>&quot;</span>)
    test.firstProperty = <span class="hljs-string">&quot;123&quot;</span>
    println(<span class="hljs-string">&quot;<span class="hljs-subst">${test.firstProperty}</span>&quot;</span>)
    test.testVal
}

<span class="hljs-comment">// Kotlin has a concise syntax for declaring properties and initializing them from the primary constructor:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> firstName: String, <span class="hljs-keyword">val</span> lastName: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>)

<span class="hljs-comment">// Such declarations can also include default values of the class properties:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> firstName: String, <span class="hljs-keyword">val</span> lastName: String, <span class="hljs-keyword">var</span> isEmployed: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">true</span>)

<span class="hljs-comment">// You can use a trailing comma when you declare class properties:</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(
<span class="hljs-keyword">val</span> firstName: String,
<span class="hljs-keyword">val</span> lastName: String,
<span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>, <span class="hljs-comment">// trailing comma</span>
) { <span class="hljs-comment">/*...*/</span> }

<span class="hljs-comment">/*
VISIBILITY

PACKAGE:
public - default. Everywhere
private - file
internal - module

CLASS:
sealed - only subclass in same file

INSIDE CLASS:
public - default. Everywhere.
private - inside class, not subclasses
protected - inside class and subclasses
internal - module
*/</span>
</div></code></pre>
<h3 id="practice-time-12">Practice Time</h3>
<pre><code class="language-kotlin"><div></div></code></pre>
<h3 id="sample-code">Sample Code</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">package</span> Aquarium

<span class="hljs-comment">// Constructor</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>(id: <span class="hljs-built_in">Int</span>, name: String) {
<span class="hljs-comment">/*
* The primary constructor cannot contain any code.
* Initialization code can be placed in initializer blocks,
* which are prefixed with the init keyword.
* */</span>
<span class="hljs-comment">// As the name says,</span>
<span class="hljs-comment">// &quot;also&quot; expressions does some additional processing on the object it was invoked.</span>
<span class="hljs-comment">// Unlike let, it returns the original object instead of any new return data.</span>
<span class="hljs-keyword">var</span> firstProperty = <span class="hljs-string">&quot;First property: <span class="hljs-variable">$name</span>&quot;</span>.also(::println)
<span class="hljs-comment">// Alternative of &quot; also &quot;</span>
<span class="hljs-comment">// val b = &quot;SDads: $name&quot;.also { println(it) }</span>

<span class="hljs-keyword">init</span> {
    <span class="hljs-comment">// ....</span>
    println(<span class="hljs-string">&quot;First this block will be executed&quot;</span>)
}

<span class="hljs-keyword">val</span> secondProperty = <span class="hljs-string">&quot;Second property: <span class="hljs-subst">${name.length}</span>&quot;</span>.also(::println)

<span class="hljs-keyword">init</span> {
    println(<span class="hljs-string">&quot;Second initializer block that prints <span class="hljs-subst">${name.length}</span>&quot;</span>)
}

<span class="hljs-comment">/*
* Accessing the Backing Field
* Every property we define is backed by a field
* that can only be accessed within its get() and set() methods
* using the special field keyword.
* The field keyword is used to access or modify the property’s value.
* This allows us to define custom logic within the get() and set() methods
* */</span>
<span class="hljs-keyword">var</span> rating: <span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span>
    <span class="hljs-keyword">get</span>() {
        <span class="hljs-keyword">if</span> (field &lt; <span class="hljs-number">5</span>) {
            println(<span class="hljs-string">&quot;Warning This is a Terrible Book!&quot;</span>)
        }
        <span class="hljs-keyword">return</span> field
    }
    <span class="hljs-keyword">set</span>(value) {
        field = <span class="hljs-keyword">when</span> {
            value &gt; <span class="hljs-number">10</span> -&gt; <span class="hljs-number">10</span>
            value &lt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span>
            <span class="hljs-keyword">else</span> -&gt; value
        }
    }

<span class="hljs-comment">// Getters and setters are auto-generated in Kotlin.</span>
<span class="hljs-comment">// In Kotlin, a property doesn’t require explicit getter or setter methods:</span>
<span class="hljs-keyword">var</span> author: String = <span class="hljs-string">&quot;Frank Herbert&quot;</span>
    <span class="hljs-comment">// Redundant getter !</span>
    <span class="hljs-keyword">get</span>() {
        <span class="hljs-keyword">return</span> field
}
    <span class="hljs-comment">// Redundant setter !</span>
    <span class="hljs-keyword">set</span>(value) {
        field = value
    }
<span class="hljs-comment">/*
* Defining a custom getter or setter allows us
* to perform any number of useful operations like input validation,
* logging, or data transformations.
* By adding this business logic directly to the getter or setter,
* we ensure that it’s always performed when the property is accessed.
* Try to avoid or minimize side-effects
* in the getter and setter methods as much as possible.
* It makes our code harder to understand.
* */</span>

<span class="hljs-comment">/*
* If we want to be able to modify a property’s value,
*we mark it with the var keyword.
* If we want an immutable property, we mark it with a val keyword.
* The main difference is that val properties can’t have setters.
* */</span>
<span class="hljs-keyword">val</span> isWorthReading: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span>.rating &gt; <span class="hljs-number">5</span>
<span class="hljs-comment">//    set(value) { // A &#x27;val&#x27;-property cannot have a setter!</span>
<span class="hljs-comment">//        // ERROR</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-comment">// In this sense, the property acts as a method when using a custom getter.</span>

<span class="hljs-comment">/*
* Now any consumers of the book class can read the inventory property
* but only the Book class can modify it.
* */</span>
<span class="hljs-keyword">var</span> inventory: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>
<span class="hljs-comment">/*
* Note that the default visibility for properties is public.
* The getter will always have the same visibility as the property itself.
* For example, if the property is private, the getter is private.
* */</span>

<span class="hljs-comment">// Backing Fields</span>
<span class="hljs-comment">/*
In Kotlin, a field is only used as a part of a property
to hold its value in memory. Fields can not be declared directly.
However, when a property needs a backing field, Kotlin provides it automatically.
This backing field can be referenced in the accessors using the &quot;field&quot; identifier:
* */</span>
<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span> <span class="hljs-comment">// the initializer assigns the backing field directly</span>
    <span class="hljs-keyword">set</span>(value) {
        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span>)
            field = value
        <span class="hljs-comment">// counter = value // ERROR StackOverflow: Using actual name &#x27;counter&#x27; would make setter recursive</span>
    }

<span class="hljs-comment">//    For example, in the following case there will be no backing field:</span>
<span class="hljs-comment">//    val isEmpty: Boolean</span>
<span class="hljs-comment">//        get() = this.size == 0</span>
}

<span class="hljs-comment">/*
* A class in Kotlin can have a primary constructor and one or more secondary constructors.
* The primary constructor is part of the class header:
* it goes after the class name (and optional type parameters).
* */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonTest</span> <span class="hljs-keyword">constructor</span></span>(firstName: String) {

}

<span class="hljs-comment">// If the primary constructor does not have any annotations or visibility modifiers,</span>
<span class="hljs-comment">// the constructor keyword can be omitted:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person2</span> </span>(firstName: String) {

}

<span class="hljs-comment">// The class can also declare secondary constructors, which are prefixed with constructor</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> pets: MutableList&lt;Pet&gt; = mutableListOf())

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>{
    <span class="hljs-comment">// Secondary constructor</span>
    <span class="hljs-keyword">constructor</span>(owner: Person) {
        <span class="hljs-comment">// Add this pet to he list of its owner&#x27;s</span>
        owner.pets.add(<span class="hljs-keyword">this</span>)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> test = Test(<span class="hljs-number">24</span>, <span class="hljs-string">&quot;Melo&quot;</span>)
    println(<span class="hljs-string">&quot;Age: <span class="hljs-subst">${test.firstProperty}</span>, Name: <span class="hljs-subst">${test.secondProperty}</span>&quot;</span>)
    test.firstProperty = <span class="hljs-string">&quot;123&quot;</span>
    println(<span class="hljs-string">&quot;First Author: <span class="hljs-subst">${test.author}</span>&quot;</span>)
    test.author = <span class="hljs-string">&quot;Melo Genesis&quot;</span>
    println(<span class="hljs-string">&quot;Second Author: <span class="hljs-subst">${test.author}</span>&quot;</span>)
}
</div></code></pre>
<h3 id="practice-time-13">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Earlier, we created and filtered a list of spices. Spices are much better represented as objects than as simple strings. Because they are objects, we can perform different things with them - such as cooking.

To recap, let&#x27;s make a simple Spice class. It doesn&#x27;t do much, but it will serve as the starting point for the next practice.

Create class, SimpleSpice.
Let the class be a property with a String for the name of the spice, and a String for the level of spiciness.
Set the name to curry and the spiciness to mild.
Using a string for spiciness is nice for users, but not useful for calculations. Add a heat property to your class with a getter that returns a numeric value for spiciness. Use a value of 5 for mild.
Create an instance of SimpleSpice and print out its name and heat.*/</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleSpice</span></span>(){
    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;curry&quot;</span>
    <span class="hljs-keyword">val</span> spiciness = <span class="hljs-string">&quot;mild&quot;</span>
    <span class="hljs-keyword">val</span> heat: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() {<span class="hljs-keyword">return</span> <span class="hljs-number">5</span> }
}
<span class="hljs-keyword">val</span> simpleSpice = SimpleSpice()
println(<span class="hljs-string">&quot;<span class="hljs-subst">${simpleSpice.name}</span> <span class="hljs-subst">${simpleSpice.heat}</span>&quot;</span>)
</div></code></pre>
<h3 id="sample-codes-continued">Sample Codes Continued</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/////////////////////////////// Sample Code ///////////////////////////////////////</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aquarium</span> </span>{
    <span class="hljs-keyword">var</span> length = <span class="hljs-number">100</span>
    <span class="hljs-keyword">var</span> width = <span class="hljs-number">20</span>
    <span class="hljs-keyword">var</span> height = <span class="hljs-number">40</span>

    <span class="hljs-comment">// Sample Getter/Setter Syntax</span>
    <span class="hljs-keyword">var</span> volume: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() {
            <span class="hljs-keyword">return</span> width * height * length / <span class="hljs-number">1000</span>
        }
        <span class="hljs-keyword">set</span>(value) {
            height = (value * <span class="hljs-number">1000</span>) / (width * length)
        }

    <span class="hljs-comment">// Alternative one liner Getter/Setter Syntax</span>
    <span class="hljs-keyword">var</span> volume2: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() = width * height * length / <span class="hljs-number">1000</span>
        <span class="hljs-comment">// By convention, the name of the setter parameter is &quot; value &quot;</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>(value) { height = (value * <span class="hljs-number">1000</span>) / (width * length) }
        <span class="hljs-comment">// If we didn&#x27;t want anyone outside the class to be able to use</span>
        <span class="hljs-comment">// the setter, we could make it private</span>
        <span class="hljs-comment">// private set(value) { height = (value * 1000) / (width * length) }</span>
        <span class="hljs-comment">// In kotlin everything is public by default</span>

<span class="hljs-comment">//    fun volume(): Int {</span>
<span class="hljs-comment">//        return width * height * length / 1000</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    // Alternative, one liner</span>
<span class="hljs-comment">//    fun volume1() = width * height * length / 1000</span>
}

<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>

<span class="hljs-comment">// With default parameters constructor overloading is not needed</span>

<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Solution Code</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spice</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> spiciness: String = <span class="hljs-string">&quot;mild&quot;</span>) {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> heat: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (spiciness) {
                <span class="hljs-string">&quot;mild&quot;</span> -&gt; <span class="hljs-number">1</span>
                <span class="hljs-string">&quot;medium&quot;</span> -&gt; <span class="hljs-number">3</span>
                <span class="hljs-string">&quot;spicy&quot;</span> -&gt; <span class="hljs-number">5</span>
                <span class="hljs-string">&quot;very spicy&quot;</span> -&gt; <span class="hljs-number">7</span>
                <span class="hljs-string">&quot;extremely spicy&quot;</span> -&gt; <span class="hljs-number">10</span>
                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">0</span>
            }
        }
}

<span class="hljs-keyword">val</span> spices1 = listOf(
        Spice(<span class="hljs-string">&quot;curry&quot;</span>, <span class="hljs-string">&quot;mild&quot;</span>),
        Spice(<span class="hljs-string">&quot;pepper&quot;</span>, <span class="hljs-string">&quot;medium&quot;</span>),
        Spice(<span class="hljs-string">&quot;cayenne&quot;</span>, <span class="hljs-string">&quot;spicy&quot;</span>),
        Spice(<span class="hljs-string">&quot;ginger&quot;</span>, <span class="hljs-string">&quot;mild&quot;</span>),
        Spice(<span class="hljs-string">&quot;red curry&quot;</span>, <span class="hljs-string">&quot;medium&quot;</span>),
        Spice(<span class="hljs-string">&quot;green curry&quot;</span>, <span class="hljs-string">&quot;mild&quot;</span>),
        Spice(<span class="hljs-string">&quot;hot pepper&quot;</span>, <span class="hljs-string">&quot;extremely spicy&quot;</span>)
)

<span class="hljs-keyword">val</span> spice = Spice(<span class="hljs-string">&quot;cayenne&quot;</span>, spiciness = <span class="hljs-string">&quot;spicy&quot;</span>)

<span class="hljs-keyword">val</span> spicelist = spices1.filter {it.heat &lt; <span class="hljs-number">5</span>}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeSalt</span><span class="hljs-params">()</span></span> = Spice(<span class="hljs-string">&quot;Salt&quot;</span>)
<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>

<span class="hljs-comment">// Kotlin does not have a new keyword</span>

<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spice</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> spiciness: String = <span class="hljs-string">&quot;mild&quot;</span>) {
    <span class="hljs-keyword">val</span> heat: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (spiciness) {
                <span class="hljs-string">&quot;mild&quot;</span> -&gt; <span class="hljs-number">1</span>
                <span class="hljs-string">&quot;medium&quot;</span> -&gt; <span class="hljs-number">3</span>
                <span class="hljs-string">&quot;spicy&quot;</span> -&gt; <span class="hljs-number">5</span>
                <span class="hljs-string">&quot;very spicy&quot;</span> -&gt; <span class="hljs-number">7</span>
                <span class="hljs-string">&quot;extremely spicy&quot;</span> -&gt; <span class="hljs-number">10</span>
                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">0</span>
            }
        }
    <span class="hljs-keyword">init</span> {
        println(<span class="hljs-string">&quot;Name. <span class="hljs-variable">$name</span>, Spiciness: <span class="hljs-variable">$spiciness</span>, Heat: <span class="hljs-variable">$heat</span>&quot;</span>)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeSalt</span><span class="hljs-params">()</span></span>: Spice {
    <span class="hljs-keyword">return</span> Spice(<span class="hljs-string">&quot;Salt&quot;</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> spices = listOf&lt;Spice&gt;(
        Spice(<span class="hljs-string">&quot;curry&quot;</span>, <span class="hljs-string">&quot;mild&quot;</span>),
        Spice(<span class="hljs-string">&quot;pepper&quot;</span>, <span class="hljs-string">&quot;medium&quot;</span>),
        Spice(<span class="hljs-string">&quot;cayenne&quot;</span>, <span class="hljs-string">&quot;spicy&quot;</span>),
        Spice(<span class="hljs-string">&quot;ginger&quot;</span>, <span class="hljs-string">&quot;mild&quot;</span>),
        Spice(<span class="hljs-string">&quot;red curry&quot;</span>, <span class="hljs-string">&quot;medium&quot;</span>),
        Spice(<span class="hljs-string">&quot;green curry&quot;</span>, <span class="hljs-string">&quot;mild&quot;</span>),
        Spice(<span class="hljs-string">&quot;hot pepper&quot;</span>, <span class="hljs-string">&quot;extremely spicy&quot;</span>)
    )
    <span class="hljs-keyword">val</span> spice = spices.filter {
        it.heat &lt; <span class="hljs-number">5</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeSalt</span><span class="hljs-params">()</span></span> = Spice(<span class="hljs-string">&quot;Salt&quot;</span>)
}
<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>

<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aquarium</span> </span>(<span class="hljs-keyword">var</span> length: <span class="hljs-built_in">Int</span> = <span class="hljs-number">100</span>, <span class="hljs-keyword">var</span> width: <span class="hljs-built_in">Int</span> = <span class="hljs-number">20</span>, <span class="hljs-keyword">var</span> height: <span class="hljs-built_in">Int</span> = <span class="hljs-number">40</span>) {
    <span class="hljs-keyword">var</span> volume: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() = width * height * length / <span class="hljs-number">1000</span>
        <span class="hljs-comment">// By convention, the name of the setter parameter is &quot; value &quot;</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>(value) { height = (value * <span class="hljs-number">1000</span>) / (width * length) }

    <span class="hljs-comment">// The inferred data type is double</span>
    <span class="hljs-keyword">var</span> water = volume * <span class="hljs-number">0.9</span>

    <span class="hljs-comment">// If we need to have another constructor than the default one for our class, we can create secondary constructor</span>
    <span class="hljs-comment">// For example, instead of specifying the dimensions when we create the aquarium</span>
    <span class="hljs-comment">// we might want to specify the number of fish when we create an aquarium in buildAquarium</span>
    <span class="hljs-keyword">constructor</span>(numberOfFish: <span class="hljs-built_in">Int</span>): <span class="hljs-keyword">this</span>() {
        <span class="hljs-keyword">val</span> water = numberOfFish * <span class="hljs-number">2000</span> <span class="hljs-comment">// cm3</span>
        <span class="hljs-keyword">val</span> tank = water + water * <span class="hljs-number">0.1</span>
        height = (tank / (length * width)).toInt()
    }
    <span class="hljs-comment">// Note that we can&#x27;t mix constructor arguments, so we cannot create an aquarium passing the length and the number of fish</span>
    <span class="hljs-comment">// The arguments have to match exactly with one of the available constructors</span>
}
</div></code></pre>
<h2 id="inheritance">Inheritance</h2>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">package</span> Aquarium
<span class="hljs-keyword">import</span> kotlin.math.PI
<span class="hljs-comment">// It doesn&#x27;t say explicitly but this class actually inherits from the top level class &quot; Any &quot;</span>
<span class="hljs-comment">/*
* The first thing we have to do to be able to inherit from a class
* is make the class &quot; open &quot;, by default classes are not subclassible
* We have to explicitly allow it
* */</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aquarium</span> </span>(<span class="hljs-keyword">var</span> length: <span class="hljs-built_in">Int</span> = <span class="hljs-number">100</span>, <span class="hljs-keyword">var</span> width: <span class="hljs-built_in">Int</span> = <span class="hljs-number">20</span>, <span class="hljs-keyword">var</span> height: <span class="hljs-built_in">Int</span> = <span class="hljs-number">40</span>): Any() {
<span class="hljs-comment">// We could add &quot;Any()&quot; but it&#x27;s not required and doesn&#x27;t give anything extra</span>
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> volume: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() = width * height * length / <span class="hljs-number">1000</span>
        <span class="hljs-keyword">set</span>(value) { height = (value * <span class="hljs-number">1000</span>) / (width * length) }
    <span class="hljs-comment">// Private setters are not allowed for open properties!</span>
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> water = volume * <span class="hljs-number">0.9</span>

    <span class="hljs-keyword">constructor</span>(numberOfFish: <span class="hljs-built_in">Int</span>): <span class="hljs-keyword">this</span>() {
        <span class="hljs-keyword">val</span> water = numberOfFish * <span class="hljs-number">2000</span> <span class="hljs-comment">// cm3</span>
        <span class="hljs-keyword">val</span> tank = water + water * <span class="hljs-number">0.1</span>
        height = (tank / (length * width)).toInt()
    }
}

<span class="hljs-comment">// All classes in Kotlin have a common superclass Any, that is the default superclass for a class with no supertypes declared:</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> // <span class="hljs-title">Implicitly</span> <span class="hljs-title">inherits</span> <span class="hljs-title">from</span> <span class="hljs-title">Any</span></span>

<span class="hljs-comment">// Any has three methods: equals(), hashCode() and toString(). Thus, they are defined for all Kotlin classes.</span>

<span class="hljs-comment">// By default, Kotlin classes are final: they can’t be inherited. To make a class inheritable, mark it with the &quot;open&quot; keyword.</span>

<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> //<span class="hljs-title">Class</span> <span class="hljs-title">is</span> <span class="hljs-title">open</span> <span class="hljs-title">for</span> <span class="hljs-title">inheritance</span></span>

<span class="hljs-comment">// To declare an explicit supertype, place the type after a colon in the class header:</span>

<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span>(p: <span class="hljs-built_in">Int</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span></span>(p: <span class="hljs-built_in">Int</span>) : Base(p)


<span class="hljs-comment">// Overriding Methods</span>
<span class="hljs-comment">// Kotlin requires explicit modifiers for overridable members and overrides:</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>{
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> { <span class="hljs-comment">/*...*/</span> }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span></span> { <span class="hljs-comment">/*...*/</span> }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span>() : Shape() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> { <span class="hljs-comment">/*...*/</span> }
}

<span class="hljs-comment">// Inheritance Explanation</span>
<span class="hljs-comment">/*
* Let&#x27;s say we want to have a different type of aquarium such as cylindrical tower
* Tower tanks are a lot like regular aquariums
* But they are also different in some ways
* So we couldn&#x27;t inherit a lot of stuff from our basic aquarium
* and change the things that are different
* Now, int the same file is okay, we can create a tower tank that inherits from aquarium
* We specify the inheritance or the parent class, after the colon
* */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TowerTank</span></span>(): Aquarium() {
    <span class="hljs-comment">// We need to change how the volume is calculated</span>
    <span class="hljs-comment">// And we don&#x27;t want to fill as much water into the tall tank</span>
    <span class="hljs-comment">// We are doing this by overriding the water property in tower tank</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> water = volume * <span class="hljs-number">0.8</span>

    <span class="hljs-comment">// Members are not available for subclassing by default</span>
    <span class="hljs-comment">// This is so we don&#x27;t accidentally leak implementation details without meaning to</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> volume: <span class="hljs-built_in">Int</span>
    <span class="hljs-keyword">get</span>() = (width * height * length / <span class="hljs-number">1000</span> * PI).toInt()
    <span class="hljs-keyword">set</span>(value) {
        height = (value * <span class="hljs-number">1000</span>) / (width*length)
    }
}

<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////////// // Solution Code</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(<span class="hljs-keyword">val</span> title: String, <span class="hljs-keyword">val</span> author: String) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> currentPage = <span class="hljs-number">1</span>
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readPage</span><span class="hljs-params">()</span></span> {
        currentPage++
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">eBook</span></span>(title: String, author: String, <span class="hljs-keyword">var</span> format: String = <span class="hljs-string">&quot;text&quot;</span>) : Book(title, author) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> wordsRead = <span class="hljs-number">0</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readPage</span><span class="hljs-params">()</span></span> {
        wordsRead = wordsRead + <span class="hljs-number">250</span>
    }
}
<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>

<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(<span class="hljs-keyword">val</span> title: String, <span class="hljs-keyword">val</span> author: String) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> currentPage = <span class="hljs-number">1</span>
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readPage</span><span class="hljs-params">()</span></span> {
        currentPage++
    }
}

<span class="hljs-comment">// Subclass</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">eBook</span></span>(title: String, author: String, <span class="hljs-keyword">var</span> format: String = <span class="hljs-string">&quot;text&quot;</span>): Book(title, author) {
    <span class="hljs-keyword">var</span> wordCount = <span class="hljs-number">0</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readPage</span><span class="hljs-params">()</span></span> {
        wordCount += <span class="hljs-number">250</span>
    }
}
<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>
</div></code></pre>
<h2 id="interfaces">Interfaces</h2>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/* Different types of fish have lots in common, and they do similar things in somewhat different ways

For example; 
All fish have a color and all fish have to eat
So we want to make sure that all our fish that we create do that
Kotlin offers two ways of doing that

1) Abstract Classes
2) Interfaces

Both are classes that cannot be instantiated on their own which means you cannot create objects of those types yet

The difference is that ABSTRACT CLASSES HAVE CONSTRUCTORS while Interfaceses don&#x27;t have any constructor logic

A final thing you can do in Kotlin, when using classes that implement interfaces is create objects where you specify that the only thing you can do with them is what&#x27;s defined in the interface*/</span>


</div></code></pre>
<h3 id="interface-examples--explanations">Interface Examples &amp; Explanations</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">//////////////////////// AquariumFish.kt Class////////////////////////////</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-comment">// Simple Abstract Class</span>
<span class="hljs-comment">/*
* Because AquariumFish is abstract we can&#x27;t make instances of AquariumFish directly!
* We need to provide sub classes that implement its missing functionality
*  */</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AquariumFish</span> </span>{
    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> color: String
}

<span class="hljs-comment">// Two subclasses, we have to implement the abstract property color// otherwise</span>
<span class="hljs-comment">// it will leave us with errors// as following</span>
<span class="hljs-comment">/*
* ERROR: Class &#x27;Shark&#x27; is not abstract and does not implement
* abstract base class member public abstract val color: String
* defined in Aquarium.AquariumFish
* */</span>
<span class="hljs-comment">// Now we can use it like any other class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shark</span>: <span class="hljs-type">AquariumFish</span></span>(), FishAction {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> color = <span class="hljs-string">&quot;gray&quot;</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot;hunt and eat fish&quot;</span>)
    }
}

<span class="hljs-comment">// Add a comma and then the FishAction interface without &quot;()&quot; and implement eat</span>
<span class="hljs-comment">// You have to implement interface methods!</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plecostomus</span>: <span class="hljs-type">AquariumFish</span></span>(), FishAction {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> color = <span class="hljs-string">&quot;gold&quot;</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot;much on algae&quot;</span>)
    }
}

<span class="hljs-comment">// Interface example, FishAction that defines an eat function</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FishAction</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>
}

<span class="hljs-comment">////////////////////////////// Main ////////////////////////////////////////</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-comment">//    // Create Aquarium class instance</span>
    buildAquarium()
    makeFish()
}

<span class="hljs-comment">// If you mark a declaration private,</span>
<span class="hljs-comment">// it will only be visible the inside the file containing declaration</span>
<span class="hljs-comment">// Since we&#x27;re only going to use buildAquarium inside this file</span>
<span class="hljs-comment">// We can make it private</span>
<span class="hljs-comment">// If you mark buildAquarium &quot; internal &quot; it is visible anywhere in the same module</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">buildAquarium</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Creates new instance of Aquarium by calling its constructor</span>
    <span class="hljs-keyword">val</span> myAquarium = Aquarium()
    <span class="hljs-comment">// Under the hood, Kotlin actually made a getter for all three properties</span>
    <span class="hljs-comment">// Even though we did not write any code</span>
    println(
        <span class="hljs-string">&quot;Length: <span class="hljs-subst">${myAquarium.length}</span>&quot;</span> +
                <span class="hljs-string">&quot; Width: <span class="hljs-subst">${myAquarium.width}</span>&quot;</span> +
                <span class="hljs-string">&quot; Height: <span class="hljs-subst">${myAquarium.height}</span>&quot;</span>
    )

    <span class="hljs-comment">// We don&#x27;t have to chance &quot; myAquarium &quot; to a var because, we&#x27;re not changing the aquarium</span>
    <span class="hljs-comment">// It&#x27;s the same object we&#x27;re modifying its properties</span>
    myAquarium.height = <span class="hljs-number">80</span>
    println(<span class="hljs-string">&quot;New Height: <span class="hljs-subst">${myAquarium.height}</span> cm&quot;</span>)
    println(<span class="hljs-string">&quot;Volume: <span class="hljs-subst">${myAquarium.volume}</span> liters&quot;</span>)
    <span class="hljs-comment">// To make this more readable, let&#x27;s pass in name parameters</span>
    <span class="hljs-keyword">val</span> smallAquarium = Aquarium(length = <span class="hljs-number">20</span>, width = <span class="hljs-number">15</span>, height = <span class="hljs-number">30</span>)
    <span class="hljs-keyword">val</span> smallAquarium2 = Aquarium(numberOfFish = <span class="hljs-number">9</span>)
    println(<span class="hljs-string">&quot;Small Aquarium: Volume: <span class="hljs-subst">${smallAquarium2.volume}</span> &quot;</span> +
            <span class="hljs-string">&quot;liters with length <span class="hljs-subst">${smallAquarium2.length}</span> &quot;</span> +
            <span class="hljs-string">&quot;width <span class="hljs-subst">${smallAquarium2.width}</span> &quot;</span> +
            <span class="hljs-string">&quot;height <span class="hljs-subst">${smallAquarium2.height}</span>&quot;</span>)
}

<span class="hljs-comment">/*
* This function creates a shark and a pleco and prints out their colors
* */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeFish</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> shark = Shark()
    <span class="hljs-keyword">val</span> pleco = Plecostomus()

    println(<span class="hljs-string">&quot;Shark: <span class="hljs-subst">${shark.color}</span> \n Pleco: <span class="hljs-subst">${pleco.color}</span>&quot;</span>)

    shark.eat()
    pleco.eat()
}

<span class="hljs-comment">/*
* When a fish gets the food, it eats it, we don&#x27;t care what kind of fish it is
* as long as it can eat the food. &quot;Eat&quot; is defined in fish action, So every fish we passed
* to feed fish needs to implement fish action, we don&#x27;t care about any other properties
* As long as it implements fish action, we can use it.
* Only fish that implement fish action can be passed into &quot;feedFish&quot;
* This is a simplistic example but when you have a lot of classes
* this can help you keep clearer and more organized
* */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">feedFish</span><span class="hljs-params">(fish: <span class="hljs-type">FishAction</span>)</span></span> {
    fish.eat()
}
<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span>

<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-comment">// Simple Abstract Class</span>
<span class="hljs-comment">/*
* Because AquariumFish is abstract we can&#x27;t make instances of AquariumFish directly!
* We need to provide sub classes that implement its missing functionality
*  */</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AquariumFish</span> </span>{
    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> color: String
}

<span class="hljs-comment">// Two subclasses, we have to implement the abstract property color// otherwise</span>
<span class="hljs-comment">// it will leave us with errors// as following</span>
<span class="hljs-comment">/*
* ERROR: Class &#x27;Shark&#x27; is not abstract and does not implement
* abstract base class member public abstract val color: String
* defined in Aquarium.AquariumFish
* */</span>
<span class="hljs-comment">// Now we can use it like any other class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shark</span>: <span class="hljs-type">AquariumFish</span></span>(), FishAction {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> color = <span class="hljs-string">&quot;gray&quot;</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot;hunt and eat fish&quot;</span>)
    }
}

<span class="hljs-comment">// Add a comma and then the FishAction interface without &quot;()&quot; and implement eat</span>
<span class="hljs-comment">// You have to implement Interface methods!</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plecostomus</span>: <span class="hljs-type">AquariumFish</span></span>(), FishAction {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> color = <span class="hljs-string">&quot;gold&quot;</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot;much on algae&quot;</span>)
    }
}

<span class="hljs-comment">// Interface example, FishAction that defines an eat function</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FishAction</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>
}
<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span>

<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span>
Difference Between Abstract Classes And Interfaces
<span class="hljs-comment">// There is really only one syntax difference in Kotlin between abstract classes and interfaces.</span>
-&gt; Abstract classes can have constructors and interfaces cannot

<span class="hljs-comment">// Both abstract classes and interfaces can contain implementations of methods</span>
<span class="hljs-comment">// On interfaces we call them default implementations</span>
<span class="hljs-comment">// The big difference really is in when and how you use them</span>

<span class="hljs-comment">// Use an interface if you have a lot of methods and one or two defalt implementations like this;</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AquariumAction</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">jump</span><span class="hljs-params">()</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">catchFish</span><span class="hljs-params">()</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot;swim&quot;</span>)
    }
}

<span class="hljs-comment">// Use an abstract class anytime you can&#x27;t complete a class</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FishActionTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>
}

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AquariumFishTest</span>: <span class="hljs-type">FishActionTest {</span></span>
    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> color: String
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot;yum&quot;</span>)
    }
}

<span class="hljs-comment">// Making all aquarium fish implement &quot;FishActionTest&quot;, we can provide a default implementation for &quot;eat&quot; while leaving color abstract, that&#x27;s because there isn&#x27;t really a good default color far a fish</span>

<span class="hljs-comment">// But really Kotlin provides us a better tool for this than abstract classes</span>

<span class="hljs-comment">// INTERFACE DELEGATION let&#x27;s you add features to a class via composition</span>
<span class="hljs-comment">// Composition is when you use an instance of another class as opposed to inheriting from it</span>

<span class="hljs-comment">// Instead of requiring the caller&#x27;s sublass&#x27; giant abstract class, give them a small interface and let them delegate those interfaces to an object</span>

<span class="hljs-comment">// How do we do composition ?</span>

<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-keyword">package</span> Aquarium
<span class="hljs-comment">/*
* Interface delegation is really powerful
* and you should generally consider how to use it whenever you
* might use an abstract class in another language
* It let&#x27;s you use composition to plug-in behaviours
* instead of requiring a lot of sub classes each specialized in a different way
* */</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    delegate()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delegate</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> pleco = Plecostomus2()
    println(<span class="hljs-string">&quot;Fish has color <span class="hljs-subst">${pleco.color}</span>&quot;</span>)
    pleco.eat()
}

<span class="hljs-comment">// Let&#x27;s start breaking up aquarium fish into interfaces</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FishAction2</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>
}

<span class="hljs-comment">//</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FishColor</span> </span>{
    <span class="hljs-keyword">val</span> color: String
}

<span class="hljs-comment">/*
* We can remove inheritance from aquarium fish
* because we get all the functionality from the interfaces
* and we don&#x27;t even have to change the code in the body of plecostomus
* */</span>
<span class="hljs-comment">// Fish color could have been implemented by a class instead of object</span>
<span class="hljs-comment">// But this time, we would have had to create many unnecessary same class objects</span>
<span class="hljs-comment">// Here, FishColor interface is implemented by GoldColor object which will be only one</span>
<span class="hljs-comment">// object at all</span>
<span class="hljs-comment">/* This means implement the interface fish color,
by deferring all calls to the object, gold color
So everytime you call the color property on this class, it will actually
call the color property on gold color
* */</span>
<span class="hljs-comment">/*
* Of course there are different colors of plecostomi in the world
* So we can make the fish color object a constructor parameter
* with a default of gold color and defer calls to the color property whatever
* fish color we get passed in
* */</span>
<span class="hljs-comment">// Now Plecostomus2 doesn&#x27;t have a body, all its overrides are handled by</span>
<span class="hljs-comment">// interface delegation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plecostomus2</span></span>(fishColor: FishColor = GoldColor):
    FishAction2 <span class="hljs-keyword">by</span> PrintingFishAction(<span class="hljs-string">&quot;a lot of algae&quot;</span>),
    FishColor <span class="hljs-keyword">by</span> GoldColor

<span class="hljs-comment">/*
* It doesn&#x27;t really make sense to make multiple instances of
* gold color as they would all do the exact same thing
* Kotlin let&#x27;s us declare a class where we can only have one instance by using
* the keyword &quot;object&quot; instead of &quot;class&quot;
* */</span>
<span class="hljs-comment">// This will declare a class and make exactly one instance of it</span>
<span class="hljs-comment">// The instance will be called gold color and there&#x27;s no way</span>
<span class="hljs-comment">// to make another instance of this class but that&#x27;s okay we don&#x27;t need to</span>
<span class="hljs-comment">// If you&#x27;re familiar with the Singleton Pattern this is how to implement it in Kotlin</span>
<span class="hljs-comment">/*
* In software engineering, the singleton pattern is a software design pattern
* that restricts the instantiation of a class to one &quot;single&quot; instance.
* This is useful when exactly one object is needed to coordinate actions across the system.
* The term comes from the mathematical concept of a singleton.
* */</span>
<span class="hljs-keyword">object</span> GoldColor : FishColor {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> color = <span class="hljs-string">&quot;gold&quot;</span>
}

<span class="hljs-comment">// If we were passed in a red color, then fish color would be by red color and return red</span>
<span class="hljs-keyword">object</span> RedColor : FishColor {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> color = <span class="hljs-string">&quot;red&quot;</span>
}

<span class="hljs-comment">// Instead of printing a fixed string, we print our whatever food we were passed</span>
<span class="hljs-comment">// Since we have a member variable food, we can&#x27;t make PrintingFishAction an object</span>
<span class="hljs-comment">// We want a different instance for each food that we passed in</span>
<span class="hljs-comment">// Constructors are not allowed for &quot;object&quot;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintingFishAction</span></span>(<span class="hljs-keyword">val</span> food: String) : FishAction2 {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> {
        println(food)
    }
}
<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>
</div></code></pre>
<h3 id="delegation-design-pattern">Delegation Design Pattern</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">package</span> Delegation
<span class="hljs-comment">/*
* KOTLIN DELEGATION
*
* Delegation is an object oriented design pattern
* And Kotlin supports it natively
* Delegation Pattern means delegating the responsibilities
* to other objects.
* */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilePlayer</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> file: String): Player {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is playing...&quot;</span>)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileDownloader</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> file: String): Downloader {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">download</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot;<span class="hljs-variable">$file</span> downloaded&quot;</span>)
    }
}

<span class="hljs-comment">/*
* Here, we will be delegating the responsibility of
* &quot;download()&quot; and &quot;play()&quot; interfaces to
* &quot;Downloader&quot; and &quot;Player&quot; objects that we pass in
* So the class is just forwarding the responsibility
* */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaFile</span></span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> downloader: Downloader,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> player: Player
) : Downloader <span class="hljs-keyword">by</span> downloader, Player <span class="hljs-keyword">by</span> player {
    <span class="hljs-comment">/*
    * We don&#x27;t need to write following two methods
    * because Kotlin already supports delegation natively
    * This is boilerplate code
    * */</span>
<span class="hljs-comment">//    override fun download() {</span>
<span class="hljs-comment">//        downloader.download()</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    override fun play() {</span>
<span class="hljs-comment">//        player.play()</span>
<span class="hljs-comment">//    }</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> file = <span class="hljs-string">&quot;FileGenesis1.mp4&quot;</span>
    <span class="hljs-keyword">val</span> mediaFile = MediaFile(FileDownloader(file), FilePlayer(file))
    mediaFile.download()
    mediaFile.play()
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Downloader</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">download</span><span class="hljs-params">()</span></span>
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Player</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>
}
</div></code></pre>
<h3 id="difference-between-open-class-and-abstract-class">Difference Between &quot;Open Class&quot; and &quot;Abstract Class&quot;</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Imagine you have 2 classes</span>

    Class Person [parent <span class="hljs-class"><span class="hljs-keyword">class</span>]</span>
    Class Coder [sub/child <span class="hljs-class"><span class="hljs-keyword">class</span>]</span>

<span class="hljs-comment">/*When you want to inherit Coder from Person you have to make Person open, so it is available to inherit from. Meanwhile you can make objects from Person itself.

When you don&#x27;t need to make objects from parent class(in our case it&#x27;s Person) or you don&#x27;t see any meaning creating objects from it you can use abstract instead of open.

It works the same way as open does. But the main difference is that you cannot make objects from Person(parent class) anymore.

Abstract class cannot be instantiated and must be inherited, abstract classes are open for extending by default.

Open modifier on the class allows inheriting it. If the class has not open modifier it is considered final and cannot be inherited.*/</span>
</div></code></pre>
<h3 id="practice-time--abstract--interface">Practice Time | Abstract &amp; Interface</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Let&#x27;s go back to your spices. Make Spice an abstract class, and then create some subclasses that are actual spices.

It&#x27;s easiest (organizationally) if you make a new package, Spices, with a file, Spice, that has a main() function.
Copy/paste your Spice class code into that new file.
Make Spice abstract.
Create a subclass, Curry. Curry can have varying levels of spiciness, so we don&#x27;t want to use the default value, but rather pass in the spiciness value.
Spices are processed in different ways before they can be used. Add an abstract method prepareSpice to Spice, and implement it in Curry.
Curry is ground into a powder, so let&#x27;s call a method grind(). However, grinding is something that&#x27;s not unique to curry, or even to spices, and it&#x27;s always done in a grinder. So we can create an Interface, Grinder, that implements the grind() method. Do that now.
Then add the Grinder interface to the Curry class.*/</span>

<span class="hljs-comment">// Delegation</span>
<span class="hljs-comment">// Using the provided code from the lesson for guidance, add a yellow color to Curry.</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span> <span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
   delegate()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delegate</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> pleco = Plecostomus()
   println(<span class="hljs-string">&quot;Fish has has color <span class="hljs-subst">${pleco.color}</span>&quot;</span>)
   pleco.eat()
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FishAction</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FishColor</span> </span>{
   <span class="hljs-keyword">val</span> color: String
}

<span class="hljs-keyword">object</span> GoldColor : FishColor {
   <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> color = <span class="hljs-string">&quot;gold&quot;</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintingFishAction</span></span>(<span class="hljs-keyword">val</span> food: String) : FishAction {
   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> {
       println(food)
   }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plecostomus</span> </span>(fishColor: FishColor = GoldColor):
   FishAction <span class="hljs-keyword">by</span> PrintingFishAction(<span class="hljs-string">&quot;eat a lot of algae&quot;</span>),
   FishColor <span class="hljs-keyword">by</span> fishColor

<span class="hljs-comment">// Interface</span>
<span class="hljs-comment">/*Create an interface, SpiceColor, that has a color property. You can use a String for the color.
Create a singleton subclass, YellowSpiceColor, using the object keyword, because all instances of Curry and other spices can use the same YellowSpiceColor instance.
Add a color property to Curry of type SpiceColor, and set the default value to YellowSpiceColor.
Add SpiceColor as an interface, and let it be by color.
Create an instance of Curry, and print its color. However, color is actually a property common to all spices, so you can move it to the parent class.
Change your code so that the SpiceColor interface is added to the Spice class and inherited by Curry.*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spice</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> spiciness: String = <span class="hljs-string">&quot;mild&quot;</span>, color: SpiceColor) : SpiceColor <span class="hljs-keyword">by</span> color {
    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prepareSpice</span><span class="hljs-params">()</span></span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Curry</span></span>(name: String, spiciness: String, color: SpiceColor = YellowSpiceColor) : Spice(name, spiciness, color), Grinder {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">grind</span><span class="hljs-params">()</span></span> {
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prepareSpice</span><span class="hljs-params">()</span></span> {
        grind()
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Grinder</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">grind</span><span class="hljs-params">()</span></span>
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SpiceColor</span> </span>{
    <span class="hljs-keyword">val</span> color: String
}

<span class="hljs-keyword">object</span> YellowSpiceColor : SpiceColor {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> color = <span class="hljs-string">&quot;Yellow&quot;</span>
}
</div></code></pre>
<h2 id="data-classes">Data Classes</h2>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">package</span> Decorations
<span class="hljs-comment">/*
* DATA CLASSES
* Often, we have classes that mostly act as data containers
* In Kotlin, for classes that mostly hold data,
* there is a class with benefits
* */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    makeDecoration()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeDecoration</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Create instance of Decorations class</span>
    <span class="hljs-keyword">val</span> d1 = Decorations(<span class="hljs-string">&quot;granite&quot;</span>)

    <span class="hljs-comment">/*
    * With a data class printing the object
    * prints the values of properties
    * instead of just an address of the object
    * that is the object pointer
    * basically it creates toString for us to print the properties
    * */</span>
    println(d1) <span class="hljs-comment">// Decorations(rocks=granite)</span>

    <span class="hljs-comment">/*
    * Data class also provides an equals method to compare two
    * instances of a data class
    * */</span>
    <span class="hljs-keyword">val</span> d2 = Decorations(<span class="hljs-string">&quot;slate&quot;</span>)
    println(d2) <span class="hljs-comment">// Decorations(rocks=slate)</span>

    <span class="hljs-keyword">val</span> d3 = Decorations(<span class="hljs-string">&quot;slate&quot;</span>)
    println(d3) <span class="hljs-comment">// Decorations(rocks=slate)</span>

    <span class="hljs-comment">// Comparison</span>
    println(d1 == d2) <span class="hljs-comment">// false</span>
    println(d3 == d2) <span class="hljs-comment">// true</span>

    <span class="hljs-comment">// We can copy data objects using the copy method</span>
    <span class="hljs-comment">// This creates a new object with the same</span>
    <span class="hljs-comment">// property values</span>
    <span class="hljs-keyword">val</span> d4 = d3.copy()
    println(d3)
    println(d4)

    <span class="hljs-comment">// Another Decoration</span>
    <span class="hljs-keyword">val</span> d5 = Decorations2(<span class="hljs-string">&quot;crystal&quot;</span>, <span class="hljs-string">&quot;wood&quot;</span>,  <span class="hljs-string">&quot;diver&quot;</span>)
    println(d5)

    <span class="hljs-comment">/*
    * DECOMPOSITION
    * To get at the properties and assign them to variables
    * Kotlin let&#x27;s us use a process called decomposition
    * */</span>

    <span class="hljs-comment">// We can make three variables, one for each property</span>
    <span class="hljs-comment">// and assign the object to it</span>
    <span class="hljs-comment">// Kotlin puts the property values in each variable and</span>
    <span class="hljs-comment">// we can then use it</span>
    <span class="hljs-comment">// We do need to put parentheses around the variables for decomposition</span>
    <span class="hljs-comment">// The number of variables must match the number of properties</span>
    <span class="hljs-comment">// or we get compiler error</span>
    <span class="hljs-comment">// The variables are assigned in the order in which</span>
    <span class="hljs-comment">// they are declared in the class</span>
    <span class="hljs-keyword">val</span> (rock, wood, diver) = d5
    <span class="hljs-comment">// Or we can also do this alternatively</span>
    <span class="hljs-keyword">val</span> (rock2, wood2, diver2) = Decorations2(<span class="hljs-string">&quot;crystal&quot;</span>, <span class="hljs-string">&quot;wood&quot;</span>,  <span class="hljs-string">&quot;diver&quot;</span>)
    println(rock)
    println(wood)
    println(diver)
}

<span class="hljs-comment">// Data classes must have</span>
<span class="hljs-comment">// at least one primary constructor parameter</span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorations</span></span>(<span class="hljs-keyword">val</span> rocks: String) {
}

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorations2</span></span>(
    <span class="hljs-keyword">val</span> rocks: String,
    <span class="hljs-keyword">val</span> wood: String,
    <span class="hljs-keyword">val</span> diver: String) {
}
</div></code></pre>
<h3 id="practice-time-14">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Create a simple data class, SpiceContainer, that holds one spice.
Give SpiceContainer a property, label, that is derived from the name of the spice.
Create some containers with spices and print out their labels.*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiceContainer</span></span>(<span class="hljs-keyword">var</span> spice: Spice) {
    <span class="hljs-keyword">val</span> label = spice.name
}

<span class="hljs-keyword">val</span> spiceCabinet = listOf(SpiceContainer(Curry(<span class="hljs-string">&quot;Yellow Curry&quot;</span>, <span class="hljs-string">&quot;mild&quot;</span>)),
        SpiceContainer(Curry(<span class="hljs-string">&quot;Red Curry&quot;</span>, <span class="hljs-string">&quot;medium&quot;</span>)),
        SpiceContainer(Curry(<span class="hljs-string">&quot;Green Curry&quot;</span>, <span class="hljs-string">&quot;spicy&quot;</span>)))

<span class="hljs-keyword">for</span>(element <span class="hljs-keyword">in</span> spiceCabinet) println(element.label)

<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">package</span> DataClasses
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spice</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> spiciness: String = <span class="hljs-string">&quot;mild&quot;</span>, ) {
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Curry</span></span>(name: String, spice: String): Spice(name, spice) {
}

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiceContainer</span></span>(
    <span class="hljs-keyword">val</span> spice: Spice,
    <span class="hljs-keyword">val</span> label: String = spice.name,
    <span class="hljs-keyword">val</span> spiciness: String = spice.spiciness
)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> spiceCabinet = listOf(SpiceContainer(Curry(<span class="hljs-string">&quot;Yellow Curry&quot;</span>, <span class="hljs-string">&quot;mild&quot;</span>)),
        SpiceContainer(Curry(<span class="hljs-string">&quot;Red Curry&quot;</span>, <span class="hljs-string">&quot;medium&quot;</span>)),
        SpiceContainer(Curry(<span class="hljs-string">&quot;Green Curry&quot;</span>, <span class="hljs-string">&quot;spicy&quot;</span>)))
        
    <span class="hljs-keyword">for</span> (element <span class="hljs-keyword">in</span> spiceCabinet) {
        println(<span class="hljs-string">&quot;<span class="hljs-subst">${element.label}</span>, <span class="hljs-subst">${element.spiciness}</span>&quot;</span>)
    }
}
</div></code></pre>
<h2 id="special-purpose-classes--singletons-enums-sealed-classes">Special Purpose Classes | Singletons, Enums, Sealed Classes</h2>
<h3 id="singeletons--objects">Singeletons | Objects</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
* SINGLETONS - &quot;Object&quot;
*
* To create singleton, use the &quot;object&quot; keyword
* when you declare you class
*
* Anytime you&#x27;re defining a class that
* shouldn&#x27;t be instantiated multiple times
* you can use the &quot;object&quot; keyword in place of class
*
* Kotlin will instantiate exactly one instance of the class
*
* Since there can be only one MobyDick, we declare it as an object
* instead of a class
* */</span>
<span class="hljs-keyword">object</span> MobyDickWhale {
    <span class="hljs-keyword">val</span> author = <span class="hljs-string">&quot;Herman Melville&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">jump</span> <span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// ...</span>
    }
}
</div></code></pre>
<h3 id="enums">Enums</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
* ENUMS
*
* which lets you enumerate items
* enums actually define a class
* and you can give them properties or even methods
*
* Enums are like singletons, Kotlin will make
* exactly one red, exactly one green and exactly one blue
* there is no way to create more than one color object
* And, there is not any way to define more colors
* other then where the enum is declared
* */</span>
<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>(<span class="hljs-keyword">val</span> rgb: <span class="hljs-built_in">Int</span>) {
    RED(<span class="hljs-number">0xFF0000</span>),
    GREEN(<span class="hljs-number">0x00FF00</span>),
    BLUE(<span class="hljs-number">0x0000FF</span>)
}

<span class="hljs-comment">// The most basic usage of enum classes is implementing type-safe enums:</span>
<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Direction</span> </span>{
    NORTH, SOUTH, WEST, EAST
}

<span class="hljs-comment">// Each enum constant is an object. Enum constants are separated with commas.</span>
<span class="hljs-comment">// Since each enum is an instance of the enum class, it can be initialized as:</span>

<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>(<span class="hljs-keyword">val</span> rgb: <span class="hljs-built_in">Int</span>) {
        RED(<span class="hljs-number">0xFF0000</span>),
        GREEN(<span class="hljs-number">0x00FF00</span>),
        BLUE(<span class="hljs-number">0x0000FF</span>)
}
</div></code></pre>
<h3 id="sealed-classes">Sealed Classes</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
* SEALED CLASS
*
* It&#x27;s a class that can be subclassed
* but only inside the file which it&#x27;s declared
* If you try to subclass it in a different file, you&#x27;ll get an error
* This makes sealed classes a safe way to represent a fixed number of types
*
* They&#x27;re great for returning success or error from a network API
*
* */</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Seal</span> </span>{

}

<span class="hljs-comment">// If we want to create more Seals we have to put them</span>
<span class="hljs-comment">// In this file, since the Seal class is in this file!</span>
<span class="hljs-comment">// I can&#x27;t subclass Seal in any other file</span>
<span class="hljs-comment">// Since They&#x27;re all in the same file</span>
<span class="hljs-comment">// Kotlin knows statically(at compile time) about all of the subclasses</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeaLion</span>: <span class="hljs-type">Seal</span></span>()
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Walrus</span>: <span class="hljs-type">Seal</span></span>()

<span class="hljs-comment">/*
* I can use a &quot;when&quot; statement to check
* what type of seal I have
* And If I don&#x27;t match all of the types of seal
* Kotlin will give me a compiler error!
* */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">matchSeal</span><span class="hljs-params">(seal: <span class="hljs-type">Seal</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (seal) {
        <span class="hljs-keyword">is</span> Walrus -&gt; <span class="hljs-string">&quot;walrus&quot;</span>
        <span class="hljs-keyword">is</span> SeaLion -&gt; <span class="hljs-string">&quot;seaLion&quot;</span>
    }
}
</div></code></pre>
<h3 id="practice-time-15">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// You used object in the previous lesson and quiz.</span>
<span class="hljs-comment">// And now that you know about enums, here&#x27;s the code for Color as an enum:</span>

<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>(<span class="hljs-keyword">val</span> rgb: <span class="hljs-built_in">Int</span>) {
   RED(<span class="hljs-number">0xFF0000</span>), GREEN(<span class="hljs-number">0x00FF00</span>), BLUE(<span class="hljs-number">0x0000FF</span>);
}

<span class="hljs-comment">// In SpiceColor, change the type of color from String to the Color class, and set the appropriate color in YellowSpiceColor.</span>
 <span class="hljs-comment">// Hint: The color code for yellow is YELLOW(0xFFFF00)</span>

<span class="hljs-comment">// Make Spice a sealed class.</span>
  <span class="hljs-comment">// What is the effect of doing this?</span>
  <span class="hljs-comment">// Why is this useful?</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SpiceColor</span> </span>{
    <span class="hljs-keyword">val</span> color: Color
}

<span class="hljs-keyword">object</span> YellowSpiceColor : SpiceColor {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> color = Color.YELLOW
}

<span class="hljs-comment">// Answer Explanation:</span>
<span class="hljs-comment">// Making Spice a sealed class helps keep all the spices together in one file. </span>
</div></code></pre>
<h2 id="l5">Lesson 5 | Kotlin Essentials: Beyond The Basics</h2>
<h3 id="pairs">Pairs</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">package</span> Collections
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Sample Generic Pair</span>
    <span class="hljs-keyword">val</span> equipment = <span class="hljs-string">&quot;fishnet&quot;</span> to <span class="hljs-string">&quot;catching&quot;</span>
    println(equipment.first)
    println(equipment.second)

    <span class="hljs-comment">// You can also chain the pairs</span>
    <span class="hljs-keyword">val</span> chain = <span class="hljs-string">&quot;A&quot;</span> to <span class="hljs-string">&quot;B&quot;</span> to <span class="hljs-string">&quot;C&quot;</span> to <span class="hljs-string">&quot;D&quot;</span>
    println(chain.first) <span class="hljs-comment">// Output:  ((A, B), C)</span>
    println(chain.first.first.first) <span class="hljs-comment">// Output:  A</span>

    <span class="hljs-keyword">val</span> testChain = (<span class="hljs-string">&quot;A&quot;</span> to <span class="hljs-string">&quot;B&quot;</span> to <span class="hljs-string">&quot;C&quot;</span>) to <span class="hljs-string">&quot;D&quot;</span>
    println(testChain)

    <span class="hljs-comment">// You can also create triplets</span>
    <span class="hljs-keyword">val</span> triple: Triple&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>&gt; = Triple(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

    <span class="hljs-comment">// deconstructing</span>
    <span class="hljs-keyword">val</span> fishnet = <span class="hljs-string">&quot;fishnet&quot;</span> to <span class="hljs-string">&quot;catching fish&quot;</span>
    <span class="hljs-keyword">val</span> (tool, use) = fishnet
    <span class="hljs-keyword">val</span> (first, second, third) = Triple(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> ,<span class="hljs-number">3</span>)

    <span class="hljs-keyword">val</span> fishnetString = fishnet.toString()
    <span class="hljs-keyword">val</span> fishnetList = fishnet.toList()

    <span class="hljs-comment">// We can use them to return more than one variable from a function</span>
    <span class="hljs-comment">// and we can destruct it and use</span>
    <span class="hljs-keyword">val</span> (tool2, use2) = giveMeATool()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">giveMeATool</span><span class="hljs-params">()</span></span>: Pair&lt;String, String&gt; {
    <span class="hljs-keyword">return</span> Pair(<span class="hljs-string">&quot;fishnet&quot;</span>, <span class="hljs-string">&quot;catching&quot;</span>)
    <span class="hljs-comment">//    return (&quot;fishnet&quot; to &quot;catching&quot;) // Alternative</span>
}
</div></code></pre>
<h3 id="practice-time-16">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
Let&#x27;s go through an example of getting information about a book in the format of a Pair. Generally, you want information about both the title and the author, and perhaps also the year.

Let’s create a basic book class, with a title, author, and year. Of course, you could get each of the properties separately.
Create a method that returns both the title and the author as a Pair.
Create a method that returns the title, author and year as a Triple. Use the documentation to find out how to use Triple.
Create a book instance.
Print out the information about the book in a sentence, such as: “Here is your book X written by Y in Z.”
*/</span>

<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">package</span> lesson_5
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(
    <span class="hljs-keyword">val</span> title: String,
    <span class="hljs-keyword">val</span> author: String,
    <span class="hljs-keyword">val</span> year: <span class="hljs-built_in">Int</span>
) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTitleAuthor</span><span class="hljs-params">()</span></span>: Pair&lt;String, String&gt; {
        <span class="hljs-keyword">return</span> Pair(title, author)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTitleAuthorYear</span><span class="hljs-params">()</span></span>: Triple&lt;String, String, <span class="hljs-built_in">Int</span>&gt; {
        <span class="hljs-keyword">return</span> Triple(title, author, year)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">&quot;Elon Musk&quot;</span>, <span class="hljs-string">&quot;Ashlee Vance&quot;</span>, <span class="hljs-number">2012</span>)

    <span class="hljs-keyword">val</span> (title, author) = book.getTitleAuthor()
    <span class="hljs-keyword">val</span> (title1, author1, year) = book.getTitleAuthorYear()

    println(<span class="hljs-string">&quot;Here is your book <span class="hljs-subst">${book.title}</span> written by <span class="hljs-subst">${book.author}</span> in <span class="hljs-subst">${book.year}</span>&quot;</span>)
}

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(<span class="hljs-keyword">val</span> title: String, <span class="hljs-keyword">val</span> author: String, <span class="hljs-keyword">val</span> year: <span class="hljs-built_in">Int</span>) {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTitleAuthor</span><span class="hljs-params">()</span></span>: Pair&lt;String, String&gt; {
        <span class="hljs-keyword">return</span> (title to author)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTitleAuthorYear</span><span class="hljs-params">()</span></span>: Triple&lt;String, String, <span class="hljs-built_in">Int</span>&gt; {
        <span class="hljs-keyword">return</span> Triple(title, author, year)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    <span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">&quot;Romeon and Juliet&quot;</span>, <span class="hljs-string">&quot;William Shakespeare&quot;</span>, <span class="hljs-number">1597</span>)
    <span class="hljs-keyword">val</span> bookTitleAuthor = book.getTitleAuthor()
    <span class="hljs-keyword">val</span> bookTitleAuthorYear = book.getTitleAuthorYear()

    println(<span class="hljs-string">&quot;Here is your book <span class="hljs-subst">${bookTitleAuthor.first}</span> by <span class="hljs-subst">${bookTitleAuthor.second}</span>&quot;</span>)

    println(<span class="hljs-string">&quot;Here is your book <span class="hljs-subst">${bookTitleAuthorYear.first}</span> &quot;</span> +
            <span class="hljs-string">&quot;by <span class="hljs-subst">${bookTitleAuthorYear.second}</span> written in <span class="hljs-subst">${bookTitleAuthorYear.third}</span>&quot;</span>)
}
</div></code></pre>
<h3 id="practice-time-17">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
One book is rarely alone, and one author rarely writes just one book.
    Create a Set of book titles called allBooks, for example, by William Shakespeare.
    Create a Map called library that associates the set of books, allBooks, to the author.
    Use the collections function any() on library to see if any of the books are “Hamlet’
    Create a MutableMap called moreBooks, and add one title/author to it.

    Use getOrPut() to see whether a title is in the map, and if the title is not in the map, add it.

    Hints:
        any() is applied to a collection and takes a lambda as its argument, for example:

        myList.any {it.contains(“name”)}

        getOrPut() is a handy function that will check whether a key is in a map, and if it is, will return the value. Otherwise, it will add the key with the supplied value to the map.
        mapOf() may come in handy.
*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-keyword">val</span> allBooks = setOf(<span class="hljs-string">&quot;Macbeth&quot;</span>, <span class="hljs-string">&quot;Romeo and Juliet&quot;</span>, <span class="hljs-string">&quot;Hamlet&quot;</span>, <span class="hljs-string">&quot;A Midsummer Night&#x27;s Dream&quot;</span>)
<span class="hljs-keyword">val</span> library = mapOf(<span class="hljs-string">&quot;Shakespeare&quot;</span> to allBooks)
println(library.any { it.value.contains(<span class="hljs-string">&quot;Hamlet&quot;</span>) })

<span class="hljs-keyword">val</span> moreBooks = mutableMapOf&lt;String, String&gt;(<span class="hljs-string">&quot;Wilhelm Tell&quot;</span> to <span class="hljs-string">&quot;Schiller&quot;</span>)
moreBooks.getOrPut(<span class="hljs-string">&quot;Jungle Book&quot;</span>) { <span class="hljs-string">&quot;Kipling&quot;</span> }
moreBooks.getOrPut(<span class="hljs-string">&quot;Hamlet&quot;</span>) { <span class="hljs-string">&quot;Shakespeare&quot;</span> }
println(moreBooks)

<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">val</span> allBooksOfOneAuthor = setOf(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>)
<span class="hljs-comment">// { set of books, author }</span>
<span class="hljs-keyword">val</span> library = mapOf(
    <span class="hljs-string">&quot;by William Shakespeare&quot;</span> to allBooksOfOneAuthor,
    <span class="hljs-string">&quot;Genesis&quot;</span> to setOf(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>)
)

<span class="hljs-keyword">val</span> hamletFound = library.any() { it.value.contains(<span class="hljs-string">&quot;Hamlet&quot;</span>) }
println(<span class="hljs-string">&quot;Hamlet is &quot;</span> + (<span class="hljs-keyword">if</span> (hamletFound) <span class="hljs-string">&quot; &quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;not &quot;</span>) + <span class="hljs-string">&quot;in the Library&quot;</span>)

<span class="hljs-keyword">val</span> moreBooks = mutableMapOf&lt;String, Set&lt;String&gt;&gt;()
moreBooks[<span class="hljs-string">&quot;Melo&quot;</span>] = setOf(<span class="hljs-string">&quot;istanbul&quot;</span>, <span class="hljs-string">&quot;ankara&quot;</span>, <span class="hljs-string">&quot;izmir&quot;</span>)
moreBooks.getOrPut(<span class="hljs-string">&quot;Seno&quot;</span>) { setOf(<span class="hljs-string">&quot;Senosis&quot;</span>) }
</div></code></pre>
<h3 id="constants">Constants</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// We can make top level constants and assign them a value at compile time using &quot;const&quot;</span>
<span class="hljs-comment">// We have &quot;val&quot; and &quot;const val&quot; now, What is the difference?</span>
<span class="hljs-comment">// Top Level, Compile Time Constant Variable</span>
<span class="hljs-comment">// The value is always determined at compile time</span>
<span class="hljs-comment">// const value set it compile time so we cannot call and execute a function</span>
<span class="hljs-comment">// to get its value set</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> num = <span class="hljs-number">5</span>
<span class="hljs-comment">// However, const val only works at the top level and in classes declared with object</span>
<span class="hljs-comment">// Not with regular classes declared with class</span>

<span class="hljs-comment">/*
* So we can use this to create a file or object that
* contains only constants and import them one-by-one
* */</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CONSTANT = <span class="hljs-string">&quot;top-level constant&quot;</span>

<span class="hljs-keyword">object</span> Constants {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CONSTANT2 = <span class="hljs-string">&quot;top-level constant&quot;</span>
}

<span class="hljs-keyword">val</span> foo = Constants.CONSTANT2
<span class="hljs-comment">// Kotlin des not have a concept of class level constants</span>
<span class="hljs-comment">// To define constants inside a class</span>
<span class="hljs-comment">// You have to wrap them into a companion object</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-comment">/*
    * The differences between
    * &quot;Regular Objects&quot; and &quot;Companion Objects&quot; are as follows;
    *
    * -&gt; Companion objects are initialized from the static constructor
    * of the containing class, that is, they are created when the object is created
    *
    * -&gt; Plain objects are initialized lazily on the first access to that object
    * that is, when they are first used
    * */</span>
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CONSTANT3 = <span class="hljs-string">&quot;constant inside companion&quot;</span>
    }
    <span class="hljs-comment">// So you need to wrap constants in classes inside a companion object</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Difference between val and const val</span>
    <span class="hljs-comment">// With val, the value that is assigned can be determined during program execution</span>
    <span class="hljs-keyword">val</span> number = <span class="hljs-number">5</span>

    <span class="hljs-comment">// For example we can assign the return value from a function</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">complexFunctionCall</span><span class="hljs-params">()</span></span> {}
    <span class="hljs-comment">// Because we can set it during execution</span>
    <span class="hljs-keyword">val</span> result = complexFunctionCall()

    <span class="hljs-comment">// ERROR!</span>
    <span class="hljs-comment">// Modifier &#x27;const&#x27; is not applicable to &#x27;local variable&#x27;</span>
    <span class="hljs-comment">// This should be Top Level!</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> num = <span class="hljs-number">5</span>
}

<span class="hljs-comment">// There are 3 different ways in which you can create constants in Kotlin. It’s not the most exciting topic, but you’ll use constants all the time.</span>

<span class="hljs-comment">// For each situation, decide when you would use a CONSTANT, an ENUM, and a DATA CLASS. </span>
</div></code></pre>
<h3 id="quiz-question">Quiz Question</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Let’s continue with our books setup to practice creating constants in Kotlin. There are 3 different ways in which you can create constants in Kotlin. It’s not the most exciting topic, but you’ll use constants all the time.

For each situation, decide when you would use a constant, an enum, and a data class.

Situation -&gt; Data Type

1) Storing simple values without any functionality. For example, a URL or a numeric code. -&gt; use Constants

2) They are objects that store groups of values that are related. They offer type safety. -&gt; use enums

3) Creating objects that only have properties without additional functionality.
-&gt; Use data classes
*/</span>
</div></code></pre>
<h3 id="practice-time-18">Practice Time</h3>
<pre><code class="language-kotlin"><div></div></code></pre>
<h3 id="practice-time-19">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*Create a top-level constant for the maximum number of books a person could borrow.
Inside the Book class, create a method canBorrow() that returns true or false depending on whether a user has already borrowed the max number of books.
Create a Constants object that provides constants to the book. For this example, provide the BASE_URL for all books in the library catalog. Inside Book, add a method printUrl that creates and prints a URL composed of BASE_URL, the book title, and “.html”.
The base URL is really of interest to the Book class. As such, it makes sense to limit its scope to the Book class. Use a companion object to define the constant in Book.*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MAX_NUMBER_BOOKS = <span class="hljs-number">20</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">canBorrow</span><span class="hljs-params">(hasBooks: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> (hasBooks &lt; MAX_NUMBER_BOOKS)
}

<span class="hljs-keyword">object</span> Constants {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> BASE_URL = <span class="hljs-string">&quot;http://www.turtlecare.net/&quot;</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printUrl</span><span class="hljs-params">()</span></span> {
    println(Constants.BASE_URL + title + <span class="hljs-string">&quot;.html&quot;</span>)
}

<span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
    <span class="hljs-keyword">val</span> BASE_URL = <span class="hljs-string">&quot;http://www.turtlecare.net/&quot;</span>
}

<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">package</span> lesson_5
<span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> maximumBooks = <span class="hljs-number">100</span>

<span class="hljs-keyword">object</span> Constants {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> BASE_URL = <span class="hljs-string">&quot;www.library.com/&quot;</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(
    <span class="hljs-keyword">val</span> title: String,
    <span class="hljs-keyword">val</span> author: String,
    <span class="hljs-keyword">val</span> year: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">val</span> maxBooks: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
) {

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> BookURL {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> BASE_URL = <span class="hljs-string">&quot;www.library.com/&quot;</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printUrl</span><span class="hljs-params">()</span></span> {
        println(
            Constants.BASE_URL + <span class="hljs-string">&quot;/&quot;</span>
            + title + <span class="hljs-string">&quot;/&quot;</span>
            + author + <span class="hljs-string">&quot;/&quot;</span>
            + year + <span class="hljs-string">&quot;/&quot;</span>
            + <span class="hljs-string">&quot;.html&quot;</span>
        )
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTitleAuthor</span><span class="hljs-params">()</span></span>: Pair&lt;String, String&gt; {
        <span class="hljs-keyword">return</span> Pair(title, author)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTitleAuthorYear</span><span class="hljs-params">()</span></span>: Triple&lt;String, String, <span class="hljs-built_in">Int</span>&gt; {
        <span class="hljs-keyword">return</span> Triple(title, author, year)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">canBorrow</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-keyword">return</span> maxBooks &lt; maximumBooks
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">&quot;Elon Musk&quot;</span>, <span class="hljs-string">&quot;Ashlee Vance&quot;</span>, <span class="hljs-number">2012</span>)

    <span class="hljs-keyword">val</span> (title, author) = book.getTitleAuthor()
    <span class="hljs-keyword">val</span> (title1, author1, year) = book.getTitleAuthorYear()

    println(<span class="hljs-string">&quot;Here is your book <span class="hljs-subst">${book.title}</span> written by <span class="hljs-subst">${book.author}</span> in <span class="hljs-subst">${book.year}</span>&quot;</span>)
}
</div></code></pre>
<h3 id="extension-functions">Extension Functions</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
Extension Functions allow you to add functions to an existing class without having access to its source code. Under the hood, extensions do not actually modify the classes they extend. By defining a new entension you do not insert new members into the class. We merely make a new function callable with the dot-notation on variables of this type. Once we declare an extension function, it&#x27;s avaiable as if it were declared on the class.
*/</span>

<span class="hljs-comment">// Extension Functions are great way to add helpful functionality to classes that you don&#x27;t own</span>

<span class="hljs-comment">// We merely make a new function callable</span>
<span class="hljs-comment">// with the dot-notation on variables of this type</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">hasSpaces</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> found = <span class="hljs-keyword">this</span>.find { it == <span class="hljs-string">&#x27; &#x27;</span> }
    <span class="hljs-keyword">return</span> found != <span class="hljs-literal">null</span>
}

<span class="hljs-comment">// We can also write one line</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">hasSpacesShorterWay</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">this</span>.find { it == <span class="hljs-string">&#x27; &#x27;</span> } != <span class="hljs-literal">null</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">hasZero</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> found = <span class="hljs-keyword">this</span>.toString().find { it == <span class="hljs-string">&#x27;0&#x27;</span> }
    <span class="hljs-keyword">return</span> found != <span class="hljs-literal">null</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    println(<span class="hljs-string">&quot;Does it have spaces?&quot;</span>.hasSpaces())
    println(<span class="hljs-number">1232</span>.hasZero())
}

<span class="hljs-comment">// You can also use it to separate the core API from helper methods on classes you do own</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AquariumPlant</span></span>(<span class="hljs-keyword">val</span> color: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span>)
<span class="hljs-comment">// This extension function is just a helper</span>
<span class="hljs-comment">// Extension functions are defined outside of the class they extend</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> AquariumPlant.<span class="hljs-title">isRed</span><span class="hljs-params">()</span></span> = color == <span class="hljs-string">&quot;Red&quot;</span>
<span class="hljs-comment">// So, they cannot access to private variables!</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> AquariumPlant.<span class="hljs-title">isBig</span><span class="hljs-params">()</span></span> = size &gt; <span class="hljs-number">50</span>
<span class="hljs-comment">// ERROR// Cannot access &#x27;size&#x27;: it is private in &#x27;AquariumPlant&#x27;</span>

<span class="hljs-comment">// You should think of them as helper functions that rely only on the public API</span>
<span class="hljs-comment">// xtension functions are always resolved statically based on the variable they&#x27;re applied to, that is at compile time</span>

<span class="hljs-comment">// We can define extension properties too, &quot;isGreen&quot; is the property name</span>
<span class="hljs-comment">// We can use &quot;isGreen&quot; just like a regular property</span>
<span class="hljs-keyword">val</span> AquariumPlant.isGreen: <span class="hljs-built_in">Boolean</span>
    <span class="hljs-keyword">get</span>() = color == <span class="hljs-string">&quot;Green&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">propertyExample</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> plant = AquariumPlant(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">50</span>)
    println(plant.isGreen) <span class="hljs-comment">// true</span>
}
</div></code></pre>
<h3 id="extension-function-examples">Extension Function Examples</h3>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">package</span> lesson_5
<span class="hljs-comment">// We merely make a new function callable</span>
<span class="hljs-comment">// with the dot-notation on variables of this type</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">hasSpaces</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> found = <span class="hljs-keyword">this</span>.find { it == <span class="hljs-string">&#x27; &#x27;</span> }
    <span class="hljs-keyword">return</span> found != <span class="hljs-literal">null</span>
}

<span class="hljs-comment">// We can also write one line</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">hasSpacesShorterWay</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">this</span>.find { it == <span class="hljs-string">&#x27; &#x27;</span> } != <span class="hljs-literal">null</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">hasZero</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> found = <span class="hljs-keyword">this</span>.toString().find { it == <span class="hljs-string">&#x27;0&#x27;</span> }
    <span class="hljs-keyword">return</span> found != <span class="hljs-literal">null</span>
}

<span class="hljs-comment">// This extension function is just a helper</span>
<span class="hljs-comment">// Extension functions are defined outside of the class they extend</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> AquariumPlant.<span class="hljs-title">isRed</span><span class="hljs-params">()</span></span> = color == <span class="hljs-string">&quot;Red&quot;</span>
<span class="hljs-comment">// So, they cannot access to private variables!</span>
<span class="hljs-comment">//fun AquariumPlant.isBig() = size &gt; 50</span>
<span class="hljs-comment">// ERROR// Cannot access &#x27;size&#x27;: it is private in &#x27;AquariumPlant&#x27;</span>

<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AquariumPlant</span></span>(<span class="hljs-keyword">val</span> color: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreenLeafyPlant</span></span>(size: <span class="hljs-built_in">Int</span>): AquariumPlant(<span class="hljs-string">&quot;Green&quot;</span>, size)

<span class="hljs-function"><span class="hljs-keyword">fun</span> AquariumPlant.<span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;AquariumPlant&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">fun</span> GreenLeafyPlant.<span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;GreenLeafyPlant&quot;</span>)

<span class="hljs-comment">// We can define extension properties too, &quot;isGreen&quot; is the property name</span>
<span class="hljs-comment">// We can use &quot;isGreen&quot; just like a regular property</span>
<span class="hljs-keyword">val</span> AquariumPlant.isGreen: <span class="hljs-built_in">Boolean</span>
    <span class="hljs-keyword">get</span>() = color == <span class="hljs-string">&quot;Green&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">propertyExample</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> plant = AquariumPlant(<span class="hljs-string">&quot;Green&quot;</span>, <span class="hljs-number">50</span>)
    println(plant.isGreen) <span class="hljs-comment">// true</span>
}

<span class="hljs-comment">// We can also make the class we are extending which is sometimes called the receiver nullable</span>
<span class="hljs-comment">// If we  do that then the &quot;this&quot; variable used in the body can be null</span>
<span class="hljs-comment">// The object on which the extension function is called can be null</span>
<span class="hljs-comment">// We indicate this with a question mark after &quot;AquariumPlant?&quot; but before the dot</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> AquariumPlant?.<span class="hljs-title">pull</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Inside the body we can test for null by using &quot;?.apply&quot;</span>
    <span class="hljs-comment">// If object is not null, the apply body will be executed</span>
    <span class="hljs-keyword">this</span>?.apply {
        println(<span class="hljs-string">&quot;removing <span class="hljs-variable">$this</span>&quot;</span>)
    }
}

<span class="hljs-comment">/*
* You would want to take a nullable receiver if you expect
* the callers will want to call your extension function on nullable variables
* */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">nullableExample</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> plantNull: AquariumPlant? = <span class="hljs-literal">null</span>
    plantNull.pull() <span class="hljs-comment">// ok</span>

    <span class="hljs-keyword">val</span> plantNotNull = AquariumPlant(<span class="hljs-string">&quot;Black&quot;</span>, <span class="hljs-number">15</span>)
    plantNotNull.pull() <span class="hljs-comment">// ok</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> plant = GreenLeafyPlant(<span class="hljs-number">50</span>)
    plant.print() <span class="hljs-comment">// GreenLeafyPlant</span>
    <span class="hljs-comment">/*
    * Compiler just looks at the type of the variable
    * So at compile time, AquariumPlant is an AquariumPlant
    * So it will print &quot;AquariumPlant&quot;
    * */</span>
    <span class="hljs-keyword">val</span> aquariumPlant: AquariumPlant = plant <span class="hljs-comment">// Type is not &quot;GreenLeafyPlant&quot; anymore</span>
    aquariumPlant.print() <span class="hljs-comment">// AquariumPlant</span>
    propertyExample() <span class="hljs-comment">// true</span>
    nullableExample()
}
</div></code></pre>
<h3 id="practice-time-20">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
It can be useful to know the weight of a book, for example, for shipping. The weight of a book can change because sometimes pages get torn, and the page count changes. While calculating the weight could be defined as a method, it’s more like a helper function. Besides, it would hurt a book&#x27;s feelings to have a method that tears up its pages.

    Add a mutable property pages to Book.
    Create an extension function on Book that returns the weight of a book as the page count multiplied by 1.5 grams.
    Create another extension, tornPages(), that takes the number of torn pages as an argument and changes the page count of the book.
    Write a class Puppy with a method playWithBook() that takes a book as an argument, and removes a random number of pages from the book.
    Create a puppy and give it a book to play with, until there are no more pages.

Note: If you don’t want to give your puppy a book, then create a puzzle toy class and fill it with treats.
*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> Book.<span class="hljs-title">weight</span><span class="hljs-params">()</span></span> : <span class="hljs-built_in">Double</span> { <span class="hljs-keyword">return</span> (pages * <span class="hljs-number">1.5</span>) }

<span class="hljs-function"><span class="hljs-keyword">fun</span> Book.<span class="hljs-title">tornPages</span><span class="hljs-params">(torn: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span> (pages &gt;= torn) pages -= torn <span class="hljs-keyword">else</span> pages = <span class="hljs-number">0</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Puppy</span></span>() {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">playWithBook</span><span class="hljs-params">(book: <span class="hljs-type">Book</span>)</span></span> {
        book.tornPages(Random().nextInt(<span class="hljs-number">12</span>))
    }
}

<span class="hljs-keyword">val</span> puppy = Puppy()
<span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">&quot;Oliver Twist&quot;</span>, <span class="hljs-string">&quot;Charles Dickens&quot;</span>, <span class="hljs-number">1837</span>, <span class="hljs-number">540</span>)

<span class="hljs-keyword">while</span> (book.pages &gt; <span class="hljs-number">0</span>) {
    puppy.playWithBook(book)
    println(<span class="hljs-string">&quot;<span class="hljs-subst">${book.pages}</span> left in <span class="hljs-subst">${book.title}</span>&quot;</span>)
}
println(<span class="hljs-string">&quot;Sad puppy, no more pages in <span class="hljs-subst">${book.title}</span>. &quot;</span>)

<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">package</span> lesson_5
<span class="hljs-keyword">import</span> kotlin.random.Random

<span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> maximumBooks = <span class="hljs-number">100</span>

<span class="hljs-keyword">object</span> Constants {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> BASE_URL = <span class="hljs-string">&quot;www.library.com/&quot;</span>
}

<span class="hljs-comment">// Extension function</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> Book.<span class="hljs-title">getWeight</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Double</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1.5</span> * pages
}

<span class="hljs-comment">// Extension function</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> Book.<span class="hljs-title">tornPages</span><span class="hljs-params">(tornPages: <span class="hljs-type">Int</span>)</span></span> {
    pages -= tornPages
}

<span class="hljs-comment">// Extension function</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> Book.<span class="hljs-title">printNumOfPages</span><span class="hljs-params">()</span></span> {
    println(<span class="hljs-string">&quot;Number of pages: <span class="hljs-variable">$pages</span>&quot;</span>)
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Puppy</span></span>() {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">playWithBook</span><span class="hljs-params">(book: <span class="hljs-type">Book</span>)</span></span> {
        <span class="hljs-keyword">val</span> randPagesToTorn = Random.nextInt(<span class="hljs-number">1</span>, book.pages + <span class="hljs-number">1</span>)
        book.tornPages(randPagesToTorn)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(
    <span class="hljs-keyword">val</span> title: String,
    <span class="hljs-keyword">val</span> author: String,
    <span class="hljs-keyword">val</span> year: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">val</span> maxBooks: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,
    <span class="hljs-keyword">var</span> pages: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
) {

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> BookURL {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> BASE_URL = <span class="hljs-string">&quot;www.library.com/&quot;</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printUrl</span><span class="hljs-params">()</span></span> {
        println(
            Constants.BASE_URL + <span class="hljs-string">&quot;/&quot;</span>
            + title + <span class="hljs-string">&quot;/&quot;</span>
            + author + <span class="hljs-string">&quot;/&quot;</span>
            + year + <span class="hljs-string">&quot;/&quot;</span>
            + <span class="hljs-string">&quot;.html&quot;</span>
        )
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTitleAuthor</span><span class="hljs-params">()</span></span>: Pair&lt;String, String&gt; {
        <span class="hljs-keyword">return</span> Pair(title, author)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTitleAuthorYear</span><span class="hljs-params">()</span></span>: Triple&lt;String, String, <span class="hljs-built_in">Int</span>&gt; {
        <span class="hljs-keyword">return</span> Triple(title, author, year)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">canBorrow</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-keyword">return</span> maxBooks &lt; maximumBooks
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">&quot;Elon Musk&quot;</span>, <span class="hljs-string">&quot;Ashlee Vance&quot;</span>, <span class="hljs-number">2012</span>)

    <span class="hljs-keyword">val</span> (title, author) = book.getTitleAuthor()
    <span class="hljs-keyword">val</span> (title1, author1, year) = book.getTitleAuthorYear()

    println(<span class="hljs-string">&quot;Here is your book <span class="hljs-subst">${book.title}</span> written by <span class="hljs-subst">${book.author}</span> in <span class="hljs-subst">${book.year}</span>&quot;</span>)

    <span class="hljs-comment">//  9. Quiz: Practice Time</span>
    book.pages = <span class="hljs-number">100</span>
    <span class="hljs-keyword">val</span> pupy = Puppy()
    <span class="hljs-keyword">while</span> (book.pages &gt; <span class="hljs-number">0</span>) {
        pupy.playWithBook(book)
        book.printNumOfPages()
    }
}
</div></code></pre>
<h2 id="generic-classes">Generic Classes</h2>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// With generics we can make the list generic so it can hold any type of object</span>
<span class="hljs-comment">// It&#x27;s like you make the tyoe a wildcard(Joker) that will fit many types</span>
<span class="hljs-keyword">package</span> Aquarium.generics

<span class="hljs-comment">// GENERICS</span>
<span class="hljs-comment">// How to declare a generic class with an upper bound and use it</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    genericExample()
}

<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaterSupply</span></span>(<span class="hljs-keyword">var</span> needsProcessed: <span class="hljs-built_in">Boolean</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TapWater</span> : <span class="hljs-type">WaterSupply</span></span>(<span class="hljs-literal">true</span>) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addChemicalCleaners</span><span class="hljs-params">()</span></span> {
        needsProcessed = <span class="hljs-literal">false</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FishStoreWater</span> : <span class="hljs-type">WaterSupply</span></span>(<span class="hljs-literal">false</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LakeWater</span> : <span class="hljs-type">WaterSupply</span></span>(<span class="hljs-literal">true</span>) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filter</span><span class="hljs-params">()</span></span> {
        needsProcessed = <span class="hljs-literal">false</span>
    }
}
<span class="hljs-comment">// To ensure that our parameter must be nonnull but can still be any type</span>
<span class="hljs-comment">// We remove the question mark &quot;Aquarium&lt;T: Any?&gt;&quot; and just say &quot;Aquarium&lt;T: Any&gt;&quot;</span>
<span class="hljs-comment">// This makes it impossible to pass null</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aquarium</span>&lt;<span class="hljs-type">T: WaterSupply</span>&gt;</span>(<span class="hljs-keyword">val</span> waterSupply: T) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addWater</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// Check throws an error if condition is not true, continues otherwise</span>
        check(!waterSupply.needsProcessed) { <span class="hljs-string">&quot;water supply needs processed&quot;</span> }
        println(<span class="hljs-string">&quot;Adding water from <span class="hljs-variable">$waterSupply</span>&quot;</span>)
    }
}

<span class="hljs-comment">// But we really want to ensure our type is a water supply</span>
<span class="hljs-comment">// We can be as specific as we want with  the generic constraint and replace</span>
<span class="hljs-comment">// any with the top of any type hierarchy we want to use</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">genericExample</span><span class="hljs-params">()</span></span> {
<span class="hljs-comment">//    val aquarium = Aquarium(TapWater()) // Type inference</span>
    <span class="hljs-keyword">val</span> aquarium = Aquarium&lt;TapWater&gt;(TapWater())
    aquarium.waterSupply.addChemicalCleaners()

    <span class="hljs-comment">// We are able to pass a string in as a water supply</span>
    <span class="hljs-comment">// This is because type T doesn&#x27;t have any bounds</span>
    <span class="hljs-comment">// So it can actually be set to any type, that could be a problem</span>
<span class="hljs-comment">//    val aquarium2 = Aquarium(&quot;string&quot;)</span>
<span class="hljs-comment">//    println(aquarium2.waterSupply)</span>

    <span class="hljs-comment">// Another unexpected example is passing in nulls this also works</span>
    <span class="hljs-comment">// I didn&#x27;t really want to let WaterSupply be null</span>
    <span class="hljs-comment">// Because T can be any type including nullable</span>
<span class="hljs-comment">//    val aquarium3 = Aquarium(null)</span>
<span class="hljs-comment">//    println(aquarium3.waterSupply)</span>

    <span class="hljs-keyword">val</span> aquarium4 = Aquarium(LakeWater())
    aquarium4.waterSupply.filter()
    aquarium4.addWater()
}
</div></code></pre>
<h3 id="practice-time--generics">Practice Time | Generics</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
Using type hierarchies with generic classes follows a pretty basic pattern that we introduced in the previous segment. There was a lot of material introducing generics, but basically, when you are building them, it boils down to the following steps:

    Create a type/class hierarchy. The parent is non-specific and the sub-types/subclasses are specializations.
    There is at least one shared property between the classes/types, and it has a different value depending on the subtype (otherwise, having the sub-types is pointless).
    We then have a class that uses all the subtypes, and performs different actions depending on what the values of the subtype’s properties are.

Let’s put this into practice using building materials and a building that needs certain amounts of those materials.

    Create a new package and file and call them Buildings.
    Create a class BaseBuildingMaterial with a property numberNeeded that is set to 1. You always need 1 of the base material.
    Create two subclasses, Wood and Brick. For BaseBuildingMaterial you need 4 units of wood or 8 units of brick. Now you have a type hierarchy.
    Create a generic class Building that can take any building material as its argument, and only building materials.
    A building always requires 100 base materials. Add a property baseMaterialsNeeded and set it to 100.
    Add another property, actualMaterialsNeeded and use a one-line function to calculate this from numberNeeded of the passed-in material.

    Add a method build() that prints the type and number of materials needed.
        Hint: Use reflection to get the class and simple name: instance::class.simpleName

    Create a main function and make a building using Wood.
    If you did this correctly, running main() will print something like “400 Wood required”.
*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseBuildingMaterial</span></span>() {
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> numberNeeded = <span class="hljs-number">1</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wood</span> : <span class="hljs-type">BaseBuildingMaterial</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> numberNeeded = <span class="hljs-number">4</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brick</span> : <span class="hljs-type">BaseBuildingMaterial</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> numberNeeded = <span class="hljs-number">8</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Building</span>&lt;<span class="hljs-type">T: BaseBuildingMaterial</span>&gt;</span>(<span class="hljs-keyword">val</span> buildingMaterial: T) {
    <span class="hljs-keyword">val</span> baseMaterialsNeeded = <span class="hljs-number">100</span>
    <span class="hljs-keyword">val</span> actualMaterialsNeeded = buildingMaterial.numberNeeded * baseMaterialsNeeded

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot; <span class="hljs-variable">$actualMaterialsNeeded</span> <span class="hljs-subst">${buildingMaterial::class.simpleName}</span> required&quot;</span>)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    Building(Wood()).build()
}

<span class="hljs-comment">// Output: 400 Wood required</span>
</div></code></pre>
<h3 id="generics-in--out">Generics in &amp; out</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Out types are type parameters that only ever occur in return values of functions or on val properties</span>
<span class="hljs-comment">// In types can be used anytime the generic is only used as an argument to functions</span>

<span class="hljs-comment">/* More specifically
    -&gt; IN TYPES CAN ONLY BE PASSED INTO AN OBJECT (Can be used as parameter)
    -&gt; OUT TYPES CAN ONLY BE PASS OUT OF AN OBJECT OR RETURNED (Can be used as return values)

Constructors can take out types as arguments but functions never can
*/</span>

<span class="hljs-keyword">package</span> Aquarium.generics
<span class="hljs-comment">// GENERICS</span>
<span class="hljs-comment">// How to declare a generic class with an upper bound and use it</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    genericExample()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addItemTo</span><span class="hljs-params">(aquarium: <span class="hljs-type">Aquarium</span>&lt;<span class="hljs-type">WaterSupply</span>&gt;)</span></span> = println(<span class="hljs-string">&quot;item added&quot;</span>)

<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaterSupply</span></span>(<span class="hljs-keyword">var</span> needsProcessed: <span class="hljs-built_in">Boolean</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TapWater</span> : <span class="hljs-type">WaterSupply</span></span>(<span class="hljs-literal">true</span>) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addChemicalCleaners</span><span class="hljs-params">()</span></span> {
        needsProcessed = <span class="hljs-literal">false</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FishStoreWater</span> : <span class="hljs-type">WaterSupply</span></span>(<span class="hljs-literal">false</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LakeWater</span> : <span class="hljs-type">WaterSupply</span></span>(<span class="hljs-literal">true</span>) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filter</span><span class="hljs-params">()</span></span> {
        needsProcessed = <span class="hljs-literal">false</span>
    }
}

<span class="hljs-comment">// To ensure that our parameter must be nonnull but can still be any type</span>
<span class="hljs-comment">// We remove the question mark &quot;Aquarium&lt;T: Any?&gt;&quot; and just say &quot;Aquarium&lt;T: Any&gt;&quot;</span>
<span class="hljs-comment">// This makes it impossible to pass null</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aquarium</span>&lt;<span class="hljs-type">out T: WaterSupply</span>&gt;</span>(<span class="hljs-keyword">val</span> waterSupply: T) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addWater</span><span class="hljs-params">(cleaner: <span class="hljs-type">Cleaner</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-comment">// Check throws an error if condition is not true, continues otherwise</span>
        <span class="hljs-keyword">if</span> (waterSupply.needsProcessed) {
            cleaner.clean(waterSupply)
        }

        println(<span class="hljs-string">&quot;Adding water from <span class="hljs-variable">$waterSupply</span>&quot;</span>)
    }
}

<span class="hljs-comment">// But we really want to ensure our type is a water supply</span>
<span class="hljs-comment">// We can be as specific as we want with  the generic constraint and replace</span>
<span class="hljs-comment">// any with the top of any type hierarchy we want to use</span>

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cleaner</span>&lt;<span class="hljs-type">in T: WaterSupply</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clean</span><span class="hljs-params">(waterSupply: <span class="hljs-type">T</span>)</span></span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TapWaterCleaner</span>: <span class="hljs-type">Cleaner</span>&lt;<span class="hljs-type">TapWater</span>&gt; </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clean</span><span class="hljs-params">(waterSupply: <span class="hljs-type">TapWater</span>)</span></span> {
        waterSupply.addChemicalCleaners()
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">genericExample</span><span class="hljs-params">()</span></span> {
<span class="hljs-comment">//    val aquarium = Aquarium(TapWater()) // Type inference</span>
    <span class="hljs-keyword">val</span> aquarium = Aquarium&lt;TapWater&gt;(TapWater())
    aquarium.waterSupply.addChemicalCleaners()

    <span class="hljs-comment">// We are able to pass a string in as a water supply</span>
    <span class="hljs-comment">// This is because type T doesn&#x27;t have any bounds</span>
    <span class="hljs-comment">// So it can actually be set to any type, that could be a problem</span>
<span class="hljs-comment">//    val aquarium2 = Aquarium(&quot;string&quot;)</span>
<span class="hljs-comment">//    println(aquarium2.waterSupply)</span>

    <span class="hljs-comment">// Another unexpected example is passing in nulls this also works</span>
    <span class="hljs-comment">// I didn&#x27;t really want to let WaterSupply be null</span>
    <span class="hljs-comment">// Because T can be any type including nullable</span>
<span class="hljs-comment">//    val aquarium3 = Aquarium(null)</span>
<span class="hljs-comment">//    println(aquarium3.waterSupply)</span>

    <span class="hljs-keyword">val</span> cleaner = TapWaterCleaner()
    <span class="hljs-keyword">val</span> aquarium4 = Aquarium(TapWater())
    aquarium4.addWater(cleaner)

    <span class="hljs-comment">// If we did not put this &quot;out&quot; -&gt; &quot;class Aquarium&lt;out T: WaterSupply&gt;&quot;, it gives error!</span>
    addItemTo(aquarium)
}
</div></code></pre>
<h3 id="practice-time-21">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
That was a lot of explanations. Fortunately, IntelliJ gives you hints as to whether something should be an in or out type in your current code.

Look at the code from the previous practice and consider whether it can be an in type or an out type.
Notice that the parameter is underlined gray, and if you hover over T, IntelliJ will suggest to make it an “out” type.
*/</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Building</span>&lt;<span class="hljs-type">out T: BaseBuildingMaterial</span>&gt;</span>(<span class="hljs-keyword">val</span> buildingMaterial: T)
</div></code></pre>
<h3 id="practice-time--generic-functions">Practice Time | Generic Functions</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// We can use generic functions for methods too</span>
<span class="hljs-keyword">package</span> Aquarium.generics

<span class="hljs-comment">// GENERICS</span>
<span class="hljs-comment">// How to declare a generic class with an upper bound and use it</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    genericExample()
}

<span class="hljs-comment">// Generic Function Example</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T: WaterSupply&gt;</span> <span class="hljs-title">isWaterClean</span><span class="hljs-params">(aquarium: <span class="hljs-type">Aquarium</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
    println(<span class="hljs-string">&quot;Aquarium water is clean <span class="hljs-subst">${aquarium.waterSupply.needsProcessed}</span>&quot;</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addItemTo</span><span class="hljs-params">(aquarium: <span class="hljs-type">Aquarium</span>&lt;<span class="hljs-type">WaterSupply</span>&gt;)</span></span> = println(<span class="hljs-string">&quot;item  added&quot;</span>)

<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaterSupply</span></span>(<span class="hljs-keyword">var</span> needsProcessed: <span class="hljs-built_in">Boolean</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TapWater</span> : <span class="hljs-type">WaterSupply</span></span>(<span class="hljs-literal">true</span>) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addChemicalCleaners</span><span class="hljs-params">()</span></span> {
        needsProcessed = <span class="hljs-literal">false</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FishStoreWater</span> : <span class="hljs-type">WaterSupply</span></span>(<span class="hljs-literal">false</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LakeWater</span> : <span class="hljs-type">WaterSupply</span></span>(<span class="hljs-literal">true</span>) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filter</span><span class="hljs-params">()</span></span> {
        needsProcessed = <span class="hljs-literal">false</span>
    }
}
<span class="hljs-comment">// To ensure that our parameter must be nonnull but can still be any type</span>
<span class="hljs-comment">// We remove the question mark &quot;Aquarium&lt;T: Any?&gt;&quot; and just say &quot;Aquarium&lt;T: Any&gt;&quot;</span>
<span class="hljs-comment">// This makes it impossible to pass null</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aquarium</span>&lt;<span class="hljs-type">out T: WaterSupply</span>&gt;</span>(<span class="hljs-keyword">val</span> waterSupply: T) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addWater</span><span class="hljs-params">(cleaner: <span class="hljs-type">Cleaner</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-comment">// Check throws an error if condition is not true, continues otherwise</span>
        <span class="hljs-keyword">if</span> (waterSupply.needsProcessed) {
            cleaner.clean(waterSupply)
        }
        println(<span class="hljs-string">&quot;Adding water from <span class="hljs-variable">$waterSupply</span>&quot;</span>)
    }
    <span class="hljs-comment">// Declare a parameter type parameter R, but make it a real type</span>
    <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> R: WaterSupply&gt;</span> <span class="hljs-title">hasWaterSupplyOfType</span><span class="hljs-params">()</span></span> = waterSupply <span class="hljs-keyword">is</span> R
}

<span class="hljs-comment">// But we really want to ensure our type is a water supply</span>
<span class="hljs-comment">// We can be as specific as we want with  the generic constraint and replace</span>
<span class="hljs-comment">// any with the top of any type hierarchy we want to use</span>

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cleaner</span>&lt;<span class="hljs-type">in T: WaterSupply</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clean</span><span class="hljs-params">(waterSupply: <span class="hljs-type">T</span>)</span></span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TapWaterCleaner</span>: <span class="hljs-type">Cleaner</span>&lt;<span class="hljs-type">TapWater</span>&gt; </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clean</span><span class="hljs-params">(waterSupply: <span class="hljs-type">TapWater</span>)</span></span> {
        waterSupply.addChemicalCleaners()
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">genericExample</span><span class="hljs-params">()</span></span> {
<span class="hljs-comment">//    val aquarium = Aquarium(TapWater()) // Type inference</span>
    <span class="hljs-keyword">val</span> aquarium = Aquarium&lt;TapWater&gt;(TapWater())
    aquarium.waterSupply.addChemicalCleaners()

    <span class="hljs-comment">// We are able to pass a string in as a water supply</span>
    <span class="hljs-comment">// This is because type T doesn&#x27;t have any bounds</span>
    <span class="hljs-comment">// So it can actually be set to any type, that could be a problem</span>
<span class="hljs-comment">//    val aquarium2 = Aquarium(&quot;string&quot;)</span>
<span class="hljs-comment">//    println(aquarium2.waterSupply)</span>

    <span class="hljs-comment">// Another unexpected example is passing in nulls this also works</span>
    <span class="hljs-comment">// I didn&#x27;t really want to let WaterSupply be null</span>
    <span class="hljs-comment">// Because T can be any type including nullable</span>
<span class="hljs-comment">//    val aquarium3 = Aquarium(null)</span>
<span class="hljs-comment">//    println(aquarium3.waterSupply)</span>

    <span class="hljs-keyword">val</span> cleaner = TapWaterCleaner()
    <span class="hljs-keyword">val</span> aquarium4 = Aquarium(TapWater())
    aquarium4.addWater(cleaner)

    <span class="hljs-comment">// If we did not put this &quot;out&quot; -&gt; &quot;class Aquarium&lt;out T: WaterSupply&gt;&quot;, it gives error!</span>
    addItemTo(aquarium)

    isWaterClean&lt;TapWater&gt;(aquarium)

    aquarium4.hasWaterSupplyOfType&lt;TapWater&gt;() <span class="hljs-comment">// True</span>
    aquarium4.waterSupply.isType&lt;LakeWater&gt;() <span class="hljs-comment">// False</span>
}

<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T: WaterSupply&gt;</span> WaterSupply.<span class="hljs-title">isType</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> T
</div></code></pre>
<h3 id="practice-time-22">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
Create a generic function for type BaseBuildingMaterial and call it isSmallBuilding, which takes a Building with a building material T as an argument. If the materials needed are less than 500, print &quot;small building&quot;, otherwise, print &quot;large building&quot;.
Note: For this function, IntelliJ recommends not to inline the function. Generally, when you create a generic function, follow the IDE&#x27;s recommendation about inlining.
*/</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : BaseBuildingMaterial&gt;</span> <span class="hljs-title">isSmallBuilding</span><span class="hljs-params">(building: <span class="hljs-type">Building</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
    <span class="hljs-keyword">if</span> (building.actualMaterialsNeeded &lt; <span class="hljs-number">500</span>) println(<span class="hljs-string">&quot;Small building&quot;</span>)
    <span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;large building&quot;</span>)
}
isSmallBuilding(Building(Brick()))
</div></code></pre>
<h2 id="annotations">Annotations</h2>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
Annotations are a means of attaching metadata to code, that is, the Annotations are read by the compiler, and used to generate code or even logic Annotations are not Kotlin specific but Kotlin offers some useful annotations 

// Annotations go right before the thing that is Annotated, and most things can be annotated: Classes, Functions, Methods, and even control structures
// Some annotations can even take arguments
// They&#x27;re really useful if you are exporting Kotlin to Java, but otherwise you don&#x27;t need them that often
*/</span> 
<span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImAPlant</span>    </span>
 
<span class="hljs-meta">@Target(AnnotationTarget.PROPERTY_GETTER)</span>    
<span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnGet</span>    </span>
    
<span class="hljs-meta">@Target(AnnotationTarget.PROPERTY_SETTER)</span>    
<span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnSet</span>    </span>
    
<span class="hljs-meta">@ImAPlant</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plant</span> </span>{    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">trim</span><span class="hljs-params">()</span></span> {}    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fertilize</span><span class="hljs-params">()</span></span> {}    
    
    <span class="hljs-meta">@get:OnGet</span>    
    <span class="hljs-keyword">val</span> isGrowing: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">true</span>    
    
    <span class="hljs-meta">@set:OnSet</span>    
    <span class="hljs-keyword">var</span> needsFood: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>    
}    
    
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">reflections</span><span class="hljs-params">()</span></span> {    
    <span class="hljs-keyword">val</span> classObj = Plant::<span class="hljs-class"><span class="hljs-keyword">class</span>    </span>
    
    <span class="hljs-comment">// print all annotations    </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">annotation</span> <span class="hljs-keyword">in</span> classObj.annotations) {    
        println(<span class="hljs-keyword">annotation</span>.annotationClass.simpleName)    
    }    
    
    <span class="hljs-comment">// find one annotation, or null    </span>
    <span class="hljs-keyword">val</span> annotated = classObj    
    
    annotated?.apply {    
        println(<span class="hljs-string">&quot;Found a plant annotation!&quot;</span>)    
    }    
}
</div></code></pre>
<h2 id="labeled-breaks">Labeled Breaks</h2>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// Kotlin has several ways of controlling the flow</span>
<span class="hljs-comment">// Kotlin gives you additional control over loops with what&#x27;s called a labeled break</span>
<span class="hljs-comment">// Any expression in Kotlin may be marked with a label</span>
<span class="hljs-comment">// Labeled break can be used (labeled form) to terminate the desired loop (can be an outer loop)</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span>) {
        <span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span>) {
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) {
                <span class="hljs-keyword">break</span>
            }
        }
    }
    <span class="hljs-comment">// Labeled Breaks</span>
    <span class="hljs-symbol">loop@</span> <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span>) {
        <span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span>) {
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) {
                println()
                <span class="hljs-keyword">break</span><span class="hljs-symbol">@loop</span>
            }
        }
    } <span class="hljs-comment">// break@loop will come here</span>
    <span class="hljs-comment">// then ends the first loop</span>
    <span class="hljs-comment">// different than just &quot;break&quot; keyword</span>
}
</div></code></pre>
<h3 id="lambdas-recap">Lambdas Recap</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// A lambda is an anonymous function, a function without a name</span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span></span>(<span class="hljs-keyword">val</span> name: String)
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Lambda function</span>
    { println(<span class="hljs-string">&quot;Hello Lambda!&quot;</span>) }()

    <span class="hljs-comment">// We can assign lambda to a variable</span>
    <span class="hljs-keyword">val</span> waterFilter = { dirty: <span class="hljs-built_in">Int</span> -&gt; dirty / <span class="hljs-number">2</span> }
    <span class="hljs-comment">// Run lambda function</span>
    println(waterFilter(<span class="hljs-number">30</span>))

    <span class="hljs-keyword">val</span> myFish = listOf(Fish(<span class="hljs-string">&quot;Flipper&quot;</span>), Fish(<span class="hljs-string">&quot;Moby Dick&quot;</span>), Fish(<span class="hljs-string">&quot;Dory&quot;</span>))

    <span class="hljs-comment">// &quot;joinToString&quot; creates a string from all the names of the element</span>
    <span class="hljs-comment">// in the list separated using this applied seperator</span>
    <span class="hljs-keyword">val</span> list = myFish.filter { it.name.contains(<span class="hljs-string">&#x27;i&#x27;</span>) }.joinToString(<span class="hljs-string">&quot; &quot;</span>) { it.name }
    println(list)
}
</div></code></pre>
<h3 id="practice-time--game">Practice Time | Game</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
In this practice, you are going to write the the first part of a higher-order functions game. You will implement everything, except the higher-order functions. Let’s get started.

    Create a new file.
    Create an enum class, Directions, that has the directions NORTH, SOUTH, EAST and WEST, as well as START, and END.
    Create a class Game.
    Inside Game, declare a var, path, that is a mutable list of Direction. Initialize it with one element, START.
    Create 4 lambdas, north, south, east, and west, that add the respective direction to the path.
    Add another lambda, end, that:
        Adds END to path
        Prints “Game Over”
        Prints the path
        Clears the path
        Returns false
    Create a main function.
    Inside main(), create an instance of Game.
    To test your code so far, in main() print the path, then invoke north, east, south, west, and end. Finally, print the path again.

You should see this output:

&gt; [START]
Game Over: [START, NORTH, SOUTH, EAST, WEST, END]
[]

You will finish your game as the last practice in this course.
*/</span>

<span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// Solution Code</span>
<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Direction</span> </span>{
    NORTH, EAST, WEST, SOUTH, START, END
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> </span>{
    <span class="hljs-keyword">var</span> path = mutableListOf&lt;Direction&gt;(Direction.START)
    <span class="hljs-keyword">val</span> north = { path.add(Direction.NORTH) }
    <span class="hljs-keyword">val</span> south = { path.add(Direction.SOUTH) }
    <span class="hljs-keyword">val</span> east = { path.add(Direction.EAST) }
    <span class="hljs-keyword">val</span> west = { path.add(Direction.WEST) }
    <span class="hljs-keyword">val</span> end = { path.add(Direction.END); println(<span class="hljs-string">&quot;Game Over: <span class="hljs-variable">$path</span>&quot;</span>); path.clear(); <span class="hljs-literal">false</span> }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> {
    <span class="hljs-keyword">val</span> game = Game()
    println(game.path)
    game.north()
    game.south()
    game.east()
    game.west()
    game.end()
    println(game.path)
}

<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// My Code</span>
<span class="hljs-keyword">package</span> lesson_6
<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Directions</span> </span>{
    START, END,
    NORTH, SOUTH, EAST, WEST
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> game = Game()
    println(game.path)
    game.east() <span class="hljs-comment">// Don&#x27;t forget the add parentheses &quot;( )&quot; at the end of Lambda function</span>
    game.north()
    game.south()
    game.west()
    game.end()
    println(game.path)
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> </span>{
    <span class="hljs-keyword">var</span> path: MutableList&lt;Directions&gt; = mutableListOf(Directions.START)
    <span class="hljs-keyword">val</span> north = { path.add(Directions.NORTH) }
    <span class="hljs-keyword">val</span> south = { path.add(Directions.SOUTH) }
    <span class="hljs-keyword">val</span> east = { <span class="hljs-keyword">this</span>.path.add(Directions.EAST) }
    <span class="hljs-keyword">val</span> west = { path.add(Directions.WEST) }
    <span class="hljs-keyword">val</span> end = {
        path.add(Directions.END)
        println(<span class="hljs-string">&quot;Game Over: <span class="hljs-variable">$path</span>&quot;</span>)
        path.clear()
        <span class="hljs-literal">false</span>
    }
}
</div></code></pre>
<h2 id="higher-order-functions-1">Higher-order Functions</h2>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
* WRITING HIGHER ORDER FUNCTIONS WITH EXTENSIONS LAMBDAS
* is the most advanced part of the Kotlin Language
* */</span>

<span class="hljs-comment">// There are tons of built in functions in the Kotlin standard library that use extension lambdas</span>
<span class="hljs-comment">// A higher-order function is a function that takes another function as parameter and/or returns a function.</span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span></span>(<span class="hljs-keyword">var</span> name: String)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fishExamples()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fishExamples</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> fish = Fish(<span class="hljs-string">&quot;splashy&quot;</span>)

    <span class="hljs-comment">// &quot;run&quot; is an extension that works with all data types</span>
    <span class="hljs-comment">// It takes one lambda as its argument and returns the result of executing the lambda</span>
    println(fish.run { <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>:)&quot;</span> })

    <span class="hljs-comment">// &quot;apply&quot; is similar to run and can also be used on all data types</span>
    <span class="hljs-comment">// but unlike &quot;run&quot; which returns the result of the block function</span>
    <span class="hljs-comment">// &quot;apply&quot; returns the object it&#x27;s applied to, so if we applied it to a fish</span>
    <span class="hljs-comment">// It will return the fish object</span>
    <span class="hljs-comment">// It turns out that &quot;apply&quot; can be really useful for calling functions</span>
    <span class="hljs-comment">// on a newly created object</span>
    println(fish.apply{})

    <span class="hljs-keyword">val</span> fish2 = Fish(<span class="hljs-string">&quot;Melo&quot;</span>).apply { name = <span class="hljs-string">&quot;Genesis&quot;</span> }
    println(fish2.name)

    <span class="hljs-comment">/*
    * So the difference is that &quot;run&quot; returns the result of executing the lambda
    * while &quot;apply&quot; returns the object after the lambda has been applied
    * This is a really common patter for initializing objects
    * */</span>

    <span class="hljs-comment">// There is also &quot;let&quot;</span>
    <span class="hljs-comment">// &quot;let&quot; returns a copy of the changed objects</span>
    <span class="hljs-comment">// Let is particularly useful for chaining manipulations together</span>
    println(fish.let { it.name.capitalize() }
        .let { it + <span class="hljs-string">&quot;fish&quot;</span> }
        .let { it.length }
        .let { it + <span class="hljs-number">35</span> })

    <span class="hljs-comment">// Here we&#x27;re saying</span>
    <span class="hljs-comment">// With fish.name call this.uppercase()</span>
    <span class="hljs-comment">// Under the hood, with is a higher order function</span>
    with (fish.name) {
        <span class="hljs-comment">// We don&#x27;t actually need this, because it&#x27;s implicit</span>
        <span class="hljs-comment">// this.uppercase()</span>
        println(capitalize()) <span class="hljs-comment">// SPLASHY</span>
        <span class="hljs-comment">// capitalize returns a copy of the pass in string</span>
        <span class="hljs-comment">// It does not change the original string</span>
    }

    <span class="hljs-comment">// We can replace &quot;with&quot; with &quot;myWith&quot;</span>
    <span class="hljs-comment">// fish.name is our named argument and</span>
    <span class="hljs-comment">// uppercase() is our block function</span>
    myWith(fish.name) {
        <span class="hljs-comment">// block function</span>
        println(uppercase()) <span class="hljs-comment">// SPLASHY</span>
        <span class="hljs-comment">// uppercase returns a copy of the pass in string</span>
        <span class="hljs-comment">// It does not change the original string</span>
    }
    println(<span class="hljs-string">&quot;Original fish name: <span class="hljs-subst">${fish.name}</span>&quot;</span>)
}

<span class="hljs-comment">// &quot;block&quot; is now an extension function on a string object</span>
<span class="hljs-comment">// And we can apply it to a string</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">myWith</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, block: <span class="hljs-type">String</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">// We take name and call block on it</span>
    name.block()
}
</div></code></pre>
<h3 id="practice-time-23">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
Create an extension on List using a higher order function that returns all the numbers in the list that are divisible by 3. Start by creating an extension function on List that takes an lambda on Int and applies it to each item in the list. When the lambda returns zero, include the item in the output. For example, this list:

val numbers = listOf&lt;Int&gt;(1,2,3,4,5,6,7,8,9,0)

Should return
&gt; [3, 6, 9, 0]
*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> numbers = listOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>)
    println(numbers.divisibleBy3())
    println(numbers.divisibleBy { it.rem(<span class="hljs-number">3</span>) })
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> List<span class="hljs-type">&lt;Int&gt;</span>.<span class="hljs-title">divisibleBy</span><span class="hljs-params">(block: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: List&lt;<span class="hljs-built_in">Int</span>&gt; {
    <span class="hljs-keyword">val</span> result = mutableListOf&lt;<span class="hljs-built_in">Int</span>&gt;()
    <span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">if</span> (block(item) == <span class="hljs-number">0</span>) {
            result.add(item)
        }
    }
    <span class="hljs-keyword">return</span> result
}

<span class="hljs-comment">// My Code</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> List<span class="hljs-type">&lt;Int&gt;</span>.<span class="hljs-title">divisibleBy3</span><span class="hljs-params">()</span></span>: List&lt;<span class="hljs-built_in">Int</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter { it % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> }
}
</div></code></pre>
<h2 id="inline">Inline</h2>
<pre><code class="language-kotlin"><div><span class="hljs-keyword">package</span> Aquarium5
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fishExamples2()
}

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish2</span></span>(<span class="hljs-keyword">var</span> name: String)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fishExamples2</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> fish = Fish(<span class="hljs-string">&quot;splashy&quot;</span>)

    <span class="hljs-comment">// PROBLEM HERE!</span>
    <span class="hljs-comment">// Every time we call myWith, Kotlin will make a new lambda object!</span>
    <span class="hljs-comment">// Which takes CPU time and memory!</span>
    <span class="hljs-comment">// Lambdas are objects</span>
    <span class="hljs-comment">// A Lambda expression is an instance of a function interface</span>
    <span class="hljs-comment">// which is itself a subtype of object</span>
    myWith(fish.name) {
        println(uppercase()) <span class="hljs-comment">// SPLASHY</span>
    }

    <span class="hljs-comment">// To help understand, we can write it out longhand like this</span>
    <span class="hljs-comment">// Without inline an object is created every call to myWith</span>
    myWith(fish.name, <span class="hljs-keyword">object</span> : Function1&lt;String, <span class="hljs-built_in">Unit</span>&gt; {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> {
            name.capitalize()
        }
    })
    <span class="hljs-comment">// When the inline transform is applied,</span>
    <span class="hljs-comment">// the call to the lambda is replaced with the contents of the</span>
    <span class="hljs-comment">// function body of the lambda</span>
    <span class="hljs-comment">// In our myWith example when we apply the transform</span>
    <span class="hljs-comment">// capitalize is called directly on fish.name</span>
    <span class="hljs-comment">// This is really important</span>
    <span class="hljs-comment">// Kotlin let&#x27;s us define Lambda-based APIs with zero overhead</span>
    <span class="hljs-comment">// It won&#x27;t even pay the cost of calling the function myWith</span>
    <span class="hljs-comment">// since it gets inlined</span>
    <span class="hljs-comment">// Inlining large functions does increase your code size</span>
    <span class="hljs-comment">// so it&#x27;s best used for simple functions like myWith</span>

    <span class="hljs-comment">// with inline no object is created and lambda body is inlined here</span>
    fish.name.capitalize()
}

<span class="hljs-comment">// To fix this problem, Kotlin let&#x27;s us define myWith as inline</span>
<span class="hljs-comment">// That is a promise that every time myWith is called</span>
<span class="hljs-comment">// it will actually transform the source code to inLine, the function</span>
<span class="hljs-comment">// That is, the compiler will change the code to replace the Lambda</span>
<span class="hljs-comment">// with the instructions inside the Lambda, that means zero overhead</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">myWith2</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, block: <span class="hljs-type">String</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    name.block()
}
</div></code></pre>
<h3 id="practice-time-24">Practice Time</h3>
<pre><code class="language-kotlin"><div><span class="hljs-comment">/*
In this practice, you will finish your simple game using higher-order functions, that is, a function that takes functions as an argument.

    In the game class, create a function move() that takes an argument called where, which is a lambda with no arguments that returns Unit.

    Hint: Declaring a function that takes a lambda as its argument:

    fun move(where: () -&gt; Boolean )

    Inside move(), invoke the passed-in lambda.
    In the Game class, create a function makeMove() that takes a nullable String argument and returns nothing.

    Inside makeMove, test whether the String is any of the 4 directions and invoke move() with the corresponding lambda. Otherwise, invoke move() with end.

    Hint: You can call the function like this:

    move(north)

    In main() add a while loop that is always true.
    Inside the loop, print instructions to the player:

    print(&quot;Enter a direction: n/s/e/w:&quot;)

    Call makeMove() with the contents of the input from the user via readLine()
    Remove the code for testing the first version of your game.
    Run your program.

Challenge:

Create a simple “map” for your game, and when the user moves, show a description of their location. Consider the following:

    Use a Location class that takes a default width and height to track location. 4x4 is pretty manageable.
    You can create a matrix like this:

    val map = Array(width) { arrayOfNulls&lt;String&gt;(height) }

    Use an init block to initialize your map with descriptions for each location.
    When you move() also updateLocation(). There is some math involved to prevent null-pointer exceptions and keep the user from walking off the map. rem() and absoluteValue come handy.
    When you are done, zip up the code and send it to a friend to try your first Kotlin game.
*/</span>

<span class="hljs-comment">// Solution Code</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">where</span>: () -&gt; <span class="hljs-type">Boolean</span> )</span></span> {
   <span class="hljs-keyword">where</span>.invoke()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeMove</span><span class="hljs-params">(command:<span class="hljs-type">String</span>?)</span></span> {
   <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">&quot;n&quot;</span>)) move(north)
   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">&quot;s&quot;</span>)) move(south)
   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">&quot;e&quot;</span>)) move(east)
   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command.equals(<span class="hljs-string">&quot;w&quot;</span>)) move(west)
   <span class="hljs-keyword">else</span> move(end)
}

<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
   print(<span class="hljs-string">&quot;Enter a direction: n/s/e/w: &quot;</span>)
   game.makeMove(readLine())
}
<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>

<span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// My Solution</span>
<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Directions</span> </span>{
    START, END,
    NORTH, SOUTH, EAST, WEST
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Map</span></span>(<span class="hljs-keyword">val</span> width: <span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span>, <span class="hljs-keyword">val</span> height: <span class="hljs-built_in">Int</span> = <span class="hljs-number">5</span>) {
    <span class="hljs-comment">//   1 2 3 4 5</span>
    <span class="hljs-comment">// 1 . . . . .</span>
    <span class="hljs-comment">// 2 . . . . .</span>
    <span class="hljs-comment">// 3 . . C . .</span>
    <span class="hljs-comment">// 4 . . . . .</span>
    <span class="hljs-comment">// 5 . . . . .</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> location = mutableListOf(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// Center of the map { x, y }</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateLocation</span><span class="hljs-params">(direction: <span class="hljs-type">String</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-keyword">val</span> newLocation = location
        <span class="hljs-keyword">when</span> (direction) {
            <span class="hljs-string">&quot;n&quot;</span> -&gt; newLocation[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span>
            <span class="hljs-string">&quot;e&quot;</span> -&gt; newLocation[<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>
            <span class="hljs-string">&quot;s&quot;</span> -&gt; newLocation[<span class="hljs-number">0</span>] -= <span class="hljs-number">1</span>
            <span class="hljs-string">&quot;w&quot;</span> -&gt; newLocation[<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>
        }
        <span class="hljs-keyword">if</span> (isInside(newLocation[<span class="hljs-number">0</span>], newLocation[<span class="hljs-number">1</span>])) {
            location = newLocation
            printLocation()
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">else</span> {
            println(<span class="hljs-string">&quot;Oops// You cannot move outside the map!&quot;</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printLocation</span><span class="hljs-params">()</span></span> {
        println(<span class="hljs-string">&quot;X: <span class="hljs-subst">${location[<span class="hljs-number">0</span>]}</span>, Y: <span class="hljs-subst">${location[<span class="hljs-number">1</span>]}</span>&quot;</span>)
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInside</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span> || x &gt; <span class="hljs-number">5</span> || y &lt; <span class="hljs-number">1</span> || y &gt; <span class="hljs-number">5</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> game = Game()
    <span class="hljs-keyword">val</span> map = Map()
    <span class="hljs-keyword">var</span> validMove = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">while</span> (validMove) {
        print(<span class="hljs-string">&quot;Enter a direction: n/s/e/w: &quot;</span>)
        <span class="hljs-keyword">val</span> direction = readLine()
        validMove = map.updateLocation(direction)
        <span class="hljs-keyword">if</span> (validMove)
            game.makeMove(direction)
    }
    game.end()
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> </span>{
    <span class="hljs-keyword">var</span> path: MutableList&lt;Directions&gt; = mutableListOf(Directions.START)
    <span class="hljs-keyword">val</span> north = { path.add(Directions.NORTH) }
    <span class="hljs-keyword">val</span> south = { path.add(Directions.SOUTH) }
    <span class="hljs-keyword">val</span> east = { path.add(Directions.EAST) }
    <span class="hljs-keyword">val</span> west = { path.add(Directions.WEST) }
    <span class="hljs-keyword">val</span> end = {
        path.add(Directions.END)
        println(<span class="hljs-string">&quot;Game Over: <span class="hljs-variable">$path</span>&quot;</span>)
        path.clear()
        <span class="hljs-literal">false</span>
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">where</span>: () -&gt; <span class="hljs-type">Boolean</span>)</span></span> {
<span class="hljs-comment">//      where.invoke() // Alternative</span>
        <span class="hljs-keyword">where</span>()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">makeMove</span><span class="hljs-params">(direction: <span class="hljs-type">String</span>?)</span></span> {
        <span class="hljs-keyword">when</span> (direction) {
            <span class="hljs-string">&quot;n&quot;</span> -&gt; move(north)
            <span class="hljs-string">&quot;s&quot;</span> -&gt; move(south)
            <span class="hljs-string">&quot;e&quot;</span> -&gt; move(east)
            <span class="hljs-string">&quot;w&quot;</span> -&gt; move(west)
            <span class="hljs-keyword">else</span> -&gt; move(end)
        }
    }
}
</div></code></pre>
<h2 id="sam---single-abstract-method">SAM - Single Abstract Method</h2>
<pre><code class="language-kotlin"><div><span class="hljs-comment">// You&#x27;ll run into SAM all the time in APIs written in the Java </span>

<span class="hljs-comment">////////////////////////////////////// JAVA ////////////////////////////////////</span>
<span class="hljs-keyword">package</span> SAM;

<span class="hljs-comment">// Java Code</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaRun</span> </span>{
    <span class="hljs-keyword">public</span> static void runNow(Runnable runnable) {
        runnable.run();
    }
}
<span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////</span>

<span class="hljs-comment">/////////////////////////////////// KOTLIN //////////////////////////////////////</span>
<span class="hljs-keyword">package</span> SAM
<span class="hljs-comment">/*
* SAM - Single Abstract Method
You&#x27;ll run into SAM all the time in APIs written in the Java
* */</span>

<span class="hljs-comment">/*
* Runnable and callable are two examples
* Basically, SAM just means an interface with one method on it, That&#x27;s it
* In Kotlin, we have to call functions that take SAM
* as parameters all the time
* */</span>
<span class="hljs-comment">//interface Runnable {</span>
<span class="hljs-comment">//  fun run()</span>
<span class="hljs-comment">//}</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//interface Callable&lt;T&gt; {</span>
<span class="hljs-comment">//  fun call(): T</span>
<span class="hljs-comment">//}</span>
<span class="hljs-comment">//interface Runnable {</span>
<span class="hljs-comment">//  fun run()</span>
<span class="hljs-comment">//}</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//interface Callable&lt;T&gt; {</span>
<span class="hljs-comment">//  fun call(): T</span>
<span class="hljs-comment">//}</span>

<span class="hljs-comment">// Int Kotlin, we can pass a lambda in place of a SAM</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example2</span><span class="hljs-params">()</span></span> {
    JavaRun.runNow {
        println(<span class="hljs-string">&quot;Passing a lambda as a runnable&quot;</span>)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> runnable = <span class="hljs-keyword">object</span>: Runnable {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {
            println(<span class="hljs-string">&quot;I&#x27;m a runnable&quot;</span>)
        }
    }
    JavaRun.runNow(runnable)
}
</div></code></pre>

    </body>
    </html>
